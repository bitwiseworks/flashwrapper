<HTML>
<HEAD>
  <TITLE>SecureIt - the API</TITLE>
</HEAD>
<body background="backgrnd.gif" onLoad="parent.index.location.href='api.inx'; return true">
<h1>SecureIt - the API</h1>

<p>
  All APIs defined by SecureIt have a Key* prefix, to make it easy to
  distinguish them from other calls in your programs.

<p>
  The following entry points are defined in the DLL:

<h2><A name="api1">Routines for setting up SecureIt</h2>

<h3><A name="KeySetup">KeySetup: Define SecureIt parameters</h3>
<table width="100%" cellspacing=2 border=all>
<tr>
<td valign=top>C/C++</td>
<td>
VOID _cdecl KeySetup(BOOL UseSerialNo, BOOL UseHighAscii, BOOL UseRSAPassword,
                     ULONG Version, PVOID ExtraData, ULONG ExtraLen);
<pre>
<em>Ex:</em> KeySetup(TRUE, FALSE, TRUE, 0x010101, &SIBlob, SIBlobLen);
</pre>
</td>
<tr>
<td valign=top>Pascal</td>
<td>
procedure KeySetup(UseSerialNo, UseHighAscii, UseRSAPassword: Boolean;
                   Version: Longint; ExtraData: Pointer; ExtraLen: Longint);
<pre>
<em>Ex:</em> KeySetup(True, False, True, $010101, @SIBlob, SIBlobLen);
</pre>

</td>
<tr> <td valign=top>REXX</td>
<td>
call KeySetup UseSerialNo, UseHighAscii, UseRSAPassword,
              Version, ExtraData, ExtraLen
<pre>
<em>Ex:</em> call KeySetup 1, 0, 1, '010101', SIBlob, SIBlobLen
</pre>
</td>
</table>

<p>
  <em>New in v2.00.</em>  This routine must be called before most other
  SecureIt functions, including <a href="#KeyCheck">KeyCheck</a>. are
  called.  It sets up the security parameters that should be used when
  validating the password; these settings must match the ones used when
  generating the passwords or the password check will fail.

<p>
  The <b>UseSerialNo</b> parameter specifies whether the password
  contains an embedded 32-bit serial number.  If this parameter is TRUE,
  a serial number will be extracted and compared against a list of
  expired and locked serial numbers defined in the <a
  href="gendata.htm#config">GenData</a> configuration.  The status and
  value of the serial number can be queried with one of the
  <a href="#KeyGetSerialNumber">KeyGetSerialNumber</a> API calls.
  For compatibility with v1.0 passwords, this parameter should be FALSE.

<p>
  The <b>UseHighAscii</b> parameter specifies whether characters with ASCII
  values higher than 127 are used when calculating the checksum of the
  user name used for decoding the password.  Setting this parameter to
  FALSE allows users to specify their real names, even if they contain
  high-ascii characters that cannot be represented on a standard US/UK
  keyboard layout, such as Ren‚ B‘rentsen.  When calculating the name
  checksum, the high-ascii characters are treated as underscores (_).
  For compatibility with v1.0 passwords, this parameter should be TRUE
  so all characters are included in the checksum calculation.

<p>
  The <b>UseRSAPassword</b> parameter specifies whether the password
  string is encrypted using the RSA algorithm.  Using RSA-encrypted
  passwords provides a very high degree of security against illicit
  passwords, but does carry a processing overhead and tends to make the
  password strings longer.  For compatibility with v1.0 passwords, this
  parameter should be FALSE.

<p>
  The <b>Version</b> parameter indicates which Version code embedded in the
  password is considered to be valid.  This value must match the value
  specified in the MakeKey setup, or the password will be
  considered invalid.  This parameter replaces the need to call the
  v1.0 <a href="#KeySetVersion">KeySetVersion</a> entry point.  The
  default value for Version is 010101 in hex.
  <br>
  The REXX version expects a hex string in this parameter, not a decimal
  number.

<p>
  The <b>ExtraData</b> and <b>ExtraLen</b> parameters specify the
  address and length of an RSA-encrypted block of data used by several
  routines in the SecureIt DLL.  This data block contains user defined
  strings, which can be retrieved using the <a href="#KeyGetUserString">
  KeyGetUserString</a>* API calls, the numbers of locked-out serial
  numbers, expiration dates for serial numbers, and the executable code
  required to check the serial number status. You should generate the
  data blob by using the <a href="gendata.htm">GenData</a> utility,
  which outputs either a Pascal or C-style include file or a binary data
  file which you can read and pass to KeySetup.  Please refer to the
  section about <a href="gendata.htm">GenData</a> for more information.

<h3><A name="KeySetCallOffsets">KeySetCallOffsets - set relative addresses for calls</h3>

<table width="100%" cellspacing=2 border=all>
<tr>
<td valign=top>C/C++</td>
<td>
VOID _cdecl KeySetCallOffsets(ULONG High, PLONG Offsets);
<pre>
<em>Ex:</em> KeySetCallOffsets(0, &Temp);
</pre>

</td><tr><td valign=top>
Pascal</td><td>
procedure KeySetCallOffsets(const Offsets: Array of Longint);
<pre>
<em>Ex:</em> KeySetCallOffsets([Ofs(MyFunc)]);
</pre>

</td><tr><td valign=top>
REXX</td><td>
call KeySetCallOffsets Offset1, Offset2, Offset3, Offset4
<pre>
<em>Ex:</em> call KeySetCallOffsets Temp, 0, 0, 0
</pre>
</td></table>
<p>
  <em>New in v2.00.</em>  This routine should be called to define a set
  of offset values for all CallBack password fields.  When <a
  href="#KeyCheck">KeyCheck</a> or <a
  href="#KeyDisplatch">KeyDisplatch</a> is called, the values passed
  using this function will be added to the address of the call.  The
  default offset values if this routine is not called is 0.

<p>
  The Pascal version can be called using an open array constructor:
<pre>
    KeySetCallOffsets([0, Longint(@MyFunction)]);
</pre>
<p>
  The C version should pass the number of pointers passed less 1,
  followed by a pointer to an array of ULONGs specifying the offsets.  In
  other words, if you want to set the offset just for the first Call
  field, you should pass an array of length 1 and a High value of 0.

<p>
  Note, that the offset specified can be negative; the offset parameter
  is considered to be a signed 32-bit value.

<p>
  The REXX version can get valid offsets by calling one of the
  REXX-specific <a href="#KeyQueryProcAddressByName">KeyQueryProcAddress</a>
  APIs.

<h3><A name="KeySetPatchOffsets">KeySetPatchOffsets - set relative addresses for patches</h3>
<table width="100%" cellspacing=2 border=all>
<tr>
<td valign=top>C/C++</td>
<td>
VOID _cdecl KeySetPatchOffsets(ULONG High, PLONG Offsets);
<pre>
<em>Ex:</em> KeySetPatchOffsets(0, &Temp);
</pre>

</td><tr><td valign=top>
Pascal</td><td>
procedure KeySetPatchOffsets(const Offsets: Array of Longint);
<pre>
<em>Ex:</em> KeySetPatchOffsets([Ofs(MyFunc)]);
</pre>

</td><tr><td valign=top>
REXX</td><td>
call KeySetPatchOffsets Offset1, Offset2, Offset3, Offset4
<pre>
<em>Ex:</em> call KeySetPatchOffsets Temp, 0, 0, 0
</pre>
</td></table>
<p>
  <em>New in v2.00.</em>  This routine works similarly to <a
  href="#KeySetCallOffsets">KeySetCallOffsets</a> but allows you to
  define an offset address for KeyPatch fields embedded in the password.
  <p> The comments pertaining to <a
  href="#KeySetCallOffsets">KeySetCallOffsets</a> above are valid for
  this call as well.

<h3><A name="KeySetVersion">KeySetVersion - set version code</h3>
<table width="100%" cellspacing=2 border=all>
<tr>
<td valign=top>C/C++</td>
<td>
VOID _cdecl KeySetVersion(ULONG Version);
<pre>
<em>Ex:</em> KeySetVersion(0x010000);
</pre>

</td><tr><td valign=top>
Pascal</td><td>
procedure KeySetVersion( Version: Longint );
<pre>
<em>Ex:</em> KeySetVersion($010000);
</pre>

</td>
</td><tr><td valign=top>
REXX</td><td>
This call is not available from REXX
</td>
</table>
<p>
  <em>Obsolete in v2.00;</em> covered by <a
  href="#KeySetup">KeySetup</a>. Call this procedure with a version
  number; only the 3 least significant bytes of the parameter are used.
  When the key is checked, the version specified by this call must match
  the version included in the password or <a
  href="#KeyCheck">KeyCheck</a> will return FALSE.

<h3><A name="KeySetNamePsw">KeySetNamePsw - set user name and password</h3>
<table width="100%" cellspacing=2 border=all>
<tr>
<td valign=top>C/C++</td>
<td>
VOID _cdecl KeySetNamePsw(PCHAR Name, PCHAR Psw);
<pre>
<em>Ex:</em> KeySetNamePsw("UserName", "Password string");
</pre>

</td><tr><td valign=top>
Pascal</td><td>
procedure KeySetNamePsw( Name, Psw: PChar );
<pre>
<em>Ex:</em> KeySetNamePsw('UserName', 'Password string');
</pre>

</td><tr><td valign=top>
REXX</td><td>
call KeySetNamePsw(Name, Psw)
<pre>
<em>Ex:</em> call KeySetNamePsw 'UserName', 'Password string'
</pre>

</td></table>
<p>
  Call this routine to specify a name and password as entered by user
  or read from file.  The procedure takes C style strings, which
  contain the string data followed by a terminating 0.
<p>
  It is important that the KeySetNamePsw API is called exactly once
  before calling <a href="#KeyCheck">KeyCheck</a>.  Setting the name and
  password initialises a number of threads that are used when checking
  the password; setting a name and password multiple times before
  calling <a href="#KeyCheck">KeyCheck</a> may yield unpredictable
  results.
<p>
  If the name and password have not been set when calling the <a
  href="#KeyCheck">KeyCheck</a> API, KeyCheck will return FALSE.

<h3><A name="KeySetNamePswP">KeySetNamePswP - set user name and password</h3>
<table width="100%" cellspacing=2 border=all>
<tr>
<td valign=top>C/C++</td>
<td>
No C style entry point to this function
</td><tr><td valign=top>
Pascal</td><td>
procedure KeySetNamePswP( var Name, Psw: String );
<pre>
<em>Ex:</em> KeySetNamePswP('UserName', 'Password string');
</pre>

</td><tr><td valign=top>
REXX</td><td>
No REXX entry point for this function
</td></table>

<p>
  Call this routine to specify a name and password as entered by user
  or read from file.  The procedure takes Pascal style strings, which
  start with a length byte followed by string data.
<p>
  The comments about <a href="#KeySetNamePsw">KeySetNamePsw</a> apply
  equally to this API.

<h3><A name="KeySetNamePswIni">KeySetNamePswIni - set user name and password</h3>
<table width="100%" cellspacing=2 border=all>
<tr>
<td valign=top>C/C++</td>
<td>
BOOL _cdecl KeySetNamePswIni(PCHAR FileName, PCHAR AppName);
<pre>
<em>Ex:</em> if (KeySetNamePswIni("MyApp.Ini", "MyApplication"))
      printf("Name and Password retrieved and set\n");
</pre>

</td><tr><td valign=top>
Pascal</td><td>
function KeySetNamePswIni( FileName, AppName: PChar ): Boolean;
<pre>
<em>Ex:</em> if KeySetNamePswIni('MyApp.Ini', 'MyApplication') then
      Writeln('Name and Password retrieved and set');
</pre>

</td><tr><td valign=top>
REXX</td><td>
rc = KeySetNamePswIni( FileName, AppName )
<pre>
<em>Ex:</em> if KeySetNamePswIni('MyApp.Ini', 'MyApplication') = 1 then
      say "Name and Password retrieved and set"
</pre>

</td></table>
<p>
  The function attempts to read a previously validated name and
  password combination from the OS/2 style .INI file specified in the
  <b>FileName</b> parameter.

<p>
  The <b>AppName</b> parameter specifies the name of the program key
  that should be used in the ini file specified in FileName.  OS/2 Ini
  files are arranged in a way resembling an outline, where two string
  identifiers uniquely identify an entry in the file: Application name
  and Key.

<p>
  SecureIt reads the Name from the ini Key "SecureIt1" and the password
  from a key named "SecureIt2". If the ini file exists and strings are
  retrieved succesfully, the function returns TRUE; otherwise, it
  returns FALSE and the name should be set in another way before call
  the <a href="#KeyCheck">KeyCheck</a> API.

<p>
  The comments about <a href="#KeySetNamePsw">KeySetNamePsw</a> apply
  equally to this API.

<h2><a name="api2">Main SecureIt APIs</h2>

<h3><A name="KeyCheck">KeyCheck - verify name and password</h3>
<table width="100%" cellspacing=2 border=all>
<tr>
<td valign=top>C/C++</td>
<td>
BOOL _cdecl KeyCheck(BOOL Automatic);
<pre>
<em>Ex:</em> if (KeyCheck(TRUE)) printf("Password is valid\n");
</pre>

</td><tr><td valign=top>
Pascal</td><td>
function KeyCheck(Automatic: Boolean): Boolean;
<pre>
<em>Ex:</em> if KeyCheck(True) then Writeln('Password is valid');
</pre>

</td><tr><td valign=top>
REXX</td><td>
rc = KeyCheck(Automatic)
<pre>
<em>Ex:</em> if KeyCheck(1) = 1 then say "Password is valid"
</pre>

</td></table>
<p>
  This function checks the Name/Password combination specified by calls
  to <a href="#KeySetNamePsw">KeySetNamePsw</a>, <a
  href="#KeySetNamePswP">KeySetNamePswP</a> or <a
  href="#KeySetNamePswIni">KeySetNamePswIni</a>. It returns TRUE, iff the
  combination is valid, the version number matches, and the serial
  number embedded in the password (if present) is neither locked nor
  expired. Otherwise, KeyCheck returns FALSE.

<p>
  If the <b>Automatic</b> parameter is set to TRUE, all Patches
  and Callbacks specified in the password string are automatically
  executed.

<p>
  This routine should be called once only.  Store the result of the call
  in a variable and use that for checking whether the password passed
  inspection or not; do not call it more than once for each set of
  name/password combinations set.

<h3><A name="KeyDispatch">KeyDispatch - call CallBack password function</h3>
<table width="100%" cellspacing=2 border=all>
<tr>
<td valign=top>C/C++</td>
<td>
BOOL _cdecl KeyDispatch(ULONG Number);
<pre>
<em>Ex:</em> if (!KeyDispatch(1)) printf("Error dispatching\n");
</pre>

</td><tr><td valign=top>
Pascal</td><td>
function KeyDispatch(Number: Longint): Boolean;
<pre>
<em>Ex:</em> if not KeyDispatch(1) then Writeln('Error dispatching');
</pre>

</td><tr><td valign=top>
REXX</td><td>
rc = KeyDispatch(Number)
<pre>
<em>Ex:</em> if KeyDispatch(1) = 0 then say 'Error dispatching'
</pre>

</td></table>
<p>
  Call this function to call the CallBack function number specified
  in the Number parameter; the functions are numbered 1 thru 4.  The
  function returns TRUE if the call was succesful, and FALSE otherwise.

<p>
  The index number refers to the respective CallBack definition in the
  <a href="makekey.htm#callback">MakeKey</a> setup file, with the first
  CallBack definition having the number 1.

<p>
  Note: This function should only be called after <a
  href="#KeyCheck">KeyCheck</a> has validated the key and has returned a
  TRUE value.  If not, FALSE will be returned.

<h3><A name="KeyCodePatch">KeyCodePatch - perform Patch password function</h3>
<table width="100%" cellspacing=2 border=all>
<tr>
<td valign=top>C/C++</td>
<td>
BOOL _cdecl KeyCodePatch(ULONG Number);
<pre>
<em>Ex:</em> if (!KeyCodePatch(1)) printf("Error patching code\n");
</pre>

</td><tr><td valign=top>
Pascal</td><td>
function KeyCodePatch(Number: Longint): Boolean;
<pre>
<em>Ex:</em> if not KeyCodePatch(1) then Writeln('Error patching code');
</pre>

</td><tr><td valign=top>
REXX</td><td>
rc = KeyCodePatch(Number)
<pre>
<em>Ex:</em> if KeyCodePatch(1) = 0 then say 'Error patching code'
</pre>

</td></table>
<p>
  Call this function to have SecureIt patch code as specified by a
  CodePatch entry in the password string.  The patches are numbered
  1 thru 4.  KeyCodePatch returns TRUE if the patch was successfully
  applied and FALSE otherwise.

<p>
  The index number refers to the respective CodePatch definition in the
  <a href="makekey.htm#codepatch">MakeKey</a> setup file, with the first
  CodePatch definition having the number 1.

<p>
  Note: This function should only be called after <a
  href="#KeyCheck">KeyCheck</a> has validated the key and has returned a
  TRUE value.  If not, FALSE will be returned.

<h3><A name="KeyQueryUserValue">KeyQueryUserValue - get User password value</h3>
<table width="100%" cellspacing=2 border=all>
<tr>
<td valign=top>C/C++</td>
<td>
ULONG _cdecl KeyQueryUserValue(ULONG Number);
<pre>
<em>Ex:</em> UserValue = KeyQueryUserValue(1);
</pre>

</td><tr><td valign=top>
Pascal</td><td>
function KeyQueryUserValue(Number: Longint): Longint;
<pre>
<em>Ex:</em> UserValue := KeyQueryUserValue(1);
</pre>

</td><tr><td valign=top>
REXX</td><td>
Value = KeyQueryUserValue(Number)
<pre>
<em>Ex:</em> UserValue = KeyQueryUserValue(1);
</pre>

</td></table>
<p>
  Call this function to retrieve a UserValue stored in the password
  string.  If the value with the index <b>Number</b> exists, it is
  returned by this function; otherwise, 0 is returned.  The user values
  are numbered from 1 to 4.

<p>
  Note: This function should only be called after <a
  href="#KeyCheck">KeyCheck</a> has validated the key and has returned a
  TRUE value.  If not, 0 will be returned.

<h2><a name="api3">SecureIt Serial Number APIs</h2>

<h3><A name="KeyGetSerialNumber">KeyGetSerialNumber - get user's serial number</h3>
<table width="100%" cellspacing=2 border=all>
<tr>
<td valign=top>C/C++</td>
<td>
ULONG _cdecl KeyGetSerialNumber(VOID);
<pre>
<em>Ex:</em> SerialNumber = KeyGetSerialNumber();
</pre>

</td><tr><td valign=top>
Pascal</td><td>
function  KeyGetSerialNumber: Longint;
<pre>
<em>Ex:</em> SerialNumber := KeyGetSerialNumber;
</pre>

</td><tr><td valign=top>
REXX</td><td>
Serial = KeyGetSerialNumber()
<pre>
<em>Ex:</em> SerialNumber = KeyGetSerialNumber();
</pre>

</td></table>
<p>
  <em>New in v2.00.</em>  This functions returns the serial number
  contained in the password for the current user, if available.  If <a
  href="#KeyCheck">KeyCheck</a> has not yet been called, or the password
  did not contain a serial number, KeyGetSerialNumber returns -1.

<p>
  If the password does not contain a serial number, -1 is also returned.


<h3><A name="KeyGetSerialNumberStatus">KeyGetSerialNumberStatus - get status of user's serial number</h3>
<table width="100%" cellspacing=2 border=all>
<tr>
<td valign=top>C/C++</td>
<td>
BYTE _cdecl KeyGetSerialNumberStatus(VOID);
<pre>
<em>Ex:</em> Status = KeyGetSerialNumberStatus();
</pre>

</td><tr><td valign=top>
Pascal</td><td>
function  KeyGetSerialNumberStatus: snStatus;
<pre>
<em>Ex:</em> Status := KeyGetSerialNumberStatus;
</pre>

</td><tr><td valign=top>
REXX</td><td>
Status = KeyGetSerialNumberStatus()
<pre>
<em>Ex:</em> Status = KeyGetSerialNumberStatus();
</pre>
</td></table>
<p>
  <em>New in v2.00.</em>  This function returns the status of the serial
  number embedded in the password for the current user, if available.
  The possible return values are

<p>
  Pascal:
<pre>
    snStatus = (snUndefined, snValid, snLocked, snExpired);
</pre>
  C:
<pre>
    #define snUndefined  0
    #define snValid      1
    #define snLocked     2
    #define snExpired    3
</pre>
  REXX:
<pre>
    snUndefined  = 0
    snValid      = 1
    snLocked     = 2
    snExpired    = 3
</pre><p>
  snValid means that the serial number is valid.  snLocked is returned
  if the serial number was valid, but was locked out for this version
  of the software, and snExpired is returned if the serial number is
  expired and is no longer valid.
<p>
  Please refer to <a href="gendata.htm">GenData</a> for information
  about locking out serial numbers and restricting serial numbers to
  expire on a specific date.


<h3><A name="KeyGetSerialNumberExpiry">KeyGetSerialNumberExpiry - get expiry date of serial number</h3>
<table width="100%" cellspacing=2 border=all>
<tr>
<td valign=top>C/C++</td>
<td>
BOOL _cdecl KeyGetSerialNumberExpiry(PULONG Year, PULONG Month, PULONG Day);
<pre>
<em>Ex:</em> if (KeyGetSerialNumberExpiry(&Year, &Month, &Day))
      printf("Licence expires on %d-%d-%d\n", Day, Month, Year);
</pre>

</td><tr><td valign=top>
Pascal</td><td>
function  KeyGetSerialNumberExpiry(var Year, Month, Day: Longint): Boolean;
<pre>
<em>Ex:</em> if KeyGetSerialNumberExpiry(Year, Month, Day) then
      Writeln('Licence expires on ',Day,'-',Month,'-',Year);
</pre>

</td><tr><td valign=top>
REXX</td><td>
ExpiryDate = KeyGetSerialNumberExpiry([Date Format])
<pre>
<em>Ex:</em> s = KeyGetSerialNumberExpiry('N')
    if s \= "0" then
      say "Licence expires on "s
</pre>

</td></table>
<p>
  <em>New in v2.00.</em>  For serial numbers that will eventually
  expire, this function returns the date of expiry.  If the serial
  number will not expire, the function returns FALSE and does not update
  any of the parameters.  If the serial number has expired or will
  expire, it returns TRUE and updates each of the parameters.

<p>
  In REXX, the expiry date is returned as a text string, and the
  optional <b>format</b> parameter specifies the format of the returned
  string.  If the serial number does not expire, 0 is returned in REXX.

<p>
  The <b>format</b> specifier is a single letter, equivalent to the
  format specifiers used by the REXX DATE() function.  The following
  formats are supported:
<ul>
  <li>E - European (dd/mm/yy), ie 27/08/97
  <li>L - Local format, ie 27 August 1997
  <li>N - Normal (dd mmm yyyy), ie 27 Aug 1997
  <li>O - Ordered (yy/mm/dd), ie 97/08/27
  <li>S - Sorted (yyyymmdd), ie 19970827
  <li>U - USA (mm/dd/yy), ie 08/27/97
  <li>M - Month name, ie August
  <li>W - Weekday name, ie Friday
</ul>
  If no Format parameter is given, the Normal format is used.

<h2><a name="api4">SecureIt helper APIs</h2>

<h3><A name="KeyGetFileChecksum">KeyGetFileChecksum - calculate CRC of file</h3>
<table width="100%" cellspacing=2 border=all>
<tr>
<td valign=top>C/C++</td>
<td>
ULONG _cdecl KeyGetFileChecksum(PCHAR FileName, ULONG CheckLen);
<pre>
<em>Ex:</em> CheckSum = KeyGetFileChecksum("MYFILE.EXE", 0);
</pre>

</td><tr><td valign=top>
Pascal</td><td>
function KeyGetFileChecksum(FileName: PChar; CheckLen: Longint): Longint;
<pre>
<em>Ex:</em> CheckSum := KeyGetFileChecksum('MYFILE.EXE', 0);
</pre>

</td><tr><td valign=top>
REXX</td><td>
CheckSum = KeyGetFileChecksum(FileName, CheckLen)
<pre>
<em>Ex:</em> CheckSum = KeyGetFileChecksum('MYFILE.EXE', 0)
</pre>

</td></table>
<p>
  <em>New in v2.00.</em>  This function calculates a 32-bit CRC value
  (Cyclic Redundancy Check or checksum) of the file specified in
  <b>FileName</b>.  If <b>CheckLen</b> is 0, the entire file is
  checksummed; otherwise, only the first <b>CheckLen</b> bytes of the
  file are included in the checksum.

<p>
  The CRC32 routine used is similar to the one used in the ZModem
  communications protocol.

<p>Note: The REXX function returns a string of hex digits, not a decimal
number string.

<h3><A name="KeyGetCRC32">KeyGetCRC32 - calculate CRC of data</h3>
<table width="100%" cellspacing=2 border=all>
<tr>
<td valign=top>C/C++</td>
<td>
ULONG _cdecl KeyGetCRC32(PCHAR Data, ULONG Len);
<pre>
<em>Ex:</em> CheckSum = KeyGetCRC32("This is a test", 14);
</pre>

</td><tr><td valign=top>
Pascal</td><td>
function KeyGetCRC32(Data: PChar; Len: Longint): Longint;
<pre>
<em>Ex:</em> CheckSum := KeyGetCRC32('This is a test', 14);
</pre>

</td><tr><td valign=top>
REXX</td><td>
CheckSum = KeyGetCRC32(Data, Len)
<pre>
<em>Ex:</em> CheckSum = KeyGetCRC32('This is a test', 14)
</pre>

</td></table>
<p>
  <em>New in v2.00.</em>  This function can be used to calculate a 32-bit CRC
  value of any block of data of length <b>Len</b>.  If <b>Len</b> is 0,
  the CRC returned is -1.

<p>
  The CRC32 routine used is similar to the one used in the ZModem
  communications protocol.

<h3><A name="KeyScrambleStr">KeyScrambleStr - scramble string</h3>
<table width="100%" cellspacing=2 border=all>
<tr>
<td valign=top>C/C++</td>
<td>
VOID _cdecl KeyScrambleStr(PCHAR S, ULONG Seed);
<pre>
<em>Ex:</em> KeyScrambleStr(S, 672893);
</pre>

</td><tr><td valign=top>
Pascal</td><td>
procedure KeyScrambleStr(S: PChar; Seed: Longint);
<pre>
<em>Ex:</em> KeyScrambleStr(S, 672893);
</pre>

</td><tr><td valign=top>
REXX</td><td>
EncodedString = KeyScrambleStr(String, Seed)
<pre>
<em>Ex:</em> Encoded = KeyScrambleStr('A string', 672893)
</pre>

</td></table>
<p>
  Call this procedure to make a very simple scramble of a C style
  string.  A string scrambled twice with the same <b>Base</b> value results
  in the original string.
<p>
  This function is useful for scrambling text strings that you do
  not want to appear in plaintext in the data segment of your program,
  such as user name, password, serial number string, etc.
<p>
  For encrypting constant strings used in your program, you should move
  them to the <a href="gendata.htm">GenData</a> setup file and retrieve
  them using the <a href="#KeyGetUserString">KeyGetUserString</a> API call.
<p>

<h3><A name="KeyGetUserString">KeyGetUserString - get string value from data blob</h3>
<table width="100%" cellspacing=2 border=all>
<tr>
<td valign=top>C/C++</td>
<td>
ULONG _cdecl KeyGetUserString(ULONG Index, PCHAR Buffer, ULONG BufLen);
<pre>
<em>Ex:</em> Len = KeyGetUserString(0, &Buffer, sizeof(Buffer));
</pre>

</td><tr><td valign=top>
Pascal</td><td>
function KeyGetUserString(Index: Longint; Buffer: PChar; BufLen: Longint): Longint;
<pre>
<em>Ex:</em> Len := KeyGetUserString(0, @Buffer, sizeof(Buffer));
</pre>

</td><tr><td valign=top>
REXX</td><td>
String = KeyGetUserString(Index)
<pre>
<em>Ex:</em> MyString = KeyGetUserString(0)
</pre>

</td></table>
<p>
  <em>New in v2.00.</em>  This function should be called to retrieve a string
  stored in the RSA-encrypted ExtraData blob as specified in the call to
  <a href="#KeySetup">KeySetup</a>.  The function takes a 0-based string
  <b>index</b> number, a <b>buffer</b> in which to return the
  unencrypted string, and the maximum number of bytes available in the
  buffer in the <b>BufLen</b> parameter.

<p>
  If <b>Index</b> is higher than the number of strings in the data blob, this
  function will most likely crash the program.  It is the
  responsibility of the programmer to make sure this function is only
  called with a valid index.
<p>
  The function returns the length of the string filled into
  <b>Buffer</b>.

<h3><A name="KeyGetUserStringP">KeyGetUserStringP - get string value from data blob</h3>
<table width="100%" cellspacing=2 border=all>
<tr>
<td valign=top>C/C++</td>
<td>
No C style entrypoint for this function
</td><tr><td valign=top>
Pascal</td><td>
function  KeyGetUserStringP(Index: Longint): String;
<pre>
<em>Ex:</em> MyString := KeyGetUserStringP(0);
</pre>

</td><tr><td valign=top>
REXX</td><td>
No REXX style entrypoint for this function
</td></table>
<p>
  <em>New in v2.00.</em>  This function works as <a
  href="#KeyGetUserString">KeyGetUserString</a>, but returns
  a Pascal style length-preceded string, with a maximum length of 256
  characters.  If the string is longer than 255 characters, it is
  truncated by this call.

<h3><A name="KeyWriteNamePswToIni">KeyWriteNamePswToIni - write name and password to ini file</h3>
<table width="100%" cellspacing=2 border=all>
<tr>
<td valign=top>C/C++</td>
<td>
BOOL _cdecl KeyWriteNamePswToIni(PCHAR FileName, PCHAR AppName);
<pre>
<em>Ex:</em> if (KeyWriteNamePswToIni("MyApp.Ini", "MyApplication"))
      printf("Name and Password stored.\n");
</pre>

</td><tr><td valign=top>
Pascal</td><td>
function KeyWriteNamePswToIni( FileName, AppName: PChar ): Boolean;
<pre>
<em>Ex:</em> if KeyWriteNamePswToIni('MyApp.Ini', 'MyApplication') then
      Writeln('Name and Password stored.');
</pre>

</td><tr><td valign=top>
REXX</td><td>
rc = KeyWriteNamePswToIni(FileName, AppName)
<pre>
<em>Ex:</em> if KeyWriteNamePswToIni('MyApp.Ini', 'MyApplication') = 1 then
      say "Name and Password stored."
</pre>

</td></table>
<p>
  This function writes the name and password set previously to an OS/2
  style .ini file for later retrieval using the <a
  href="#KeySetNamePswIni">KeySetNamePswIni</a> API.


<h3><A name="KeyGetRegisteredName">KeyGetRegisteredName - get current user name</h3>
<table width="100%" cellspacing=2 border=all>
<tr>
<td valign=top>C/C++</td>
<td>
ULONG _cdecl KeyGetRegisteredName(PCHAR Buffer, ULONG BufLen)
<pre>
<em>Ex:</em> Len = KeyGetRegisteredName(&Buffer, sizeof(Buffer));
</pre>

</td><tr><td valign=top>
Pascal</td><td>
function KeyGetRegisteredName(Buffer: PChar; BufLen: Longint): Longint;
<pre>
<em>Ex:</em> Len := KeyGetRegisteredName(@Buffer, sizeof(Buffer));
</pre>

</td><tr><td valign=top>
REXX</td><td>
Name = KeyGetRegisteredName()
<pre>
<em>Ex:</em> say "Program registered to "KeyGetRegisteredName()
</pre>

</td></table>
<p>
  Use this function to retrieve the username that was used when
  validating the password using the <a href="#KeyCheck">KeyCheck</a>
  API.  The function takes a <b>buffer</b> where the name will be returned and
  the length of the buffer as the parameter, and returns the number of
  bytes of the buffer filled by the function.

<p>
  If the name and password were read from an .ini file using the <a
  href="#KeySetNamePswIni">KeySetNamePswIni</a> API, this is the only
  way of getting the name for displaying in About boxes, etc.

<h3><A name="KeyManualPatch">KeyManualPatch - change executable code</h3>
<table width="100%" cellspacing=2 border=all>
<tr>
<td valign=top>C/C++</td>
<td>
BOOL _cdecl KeyManualPatch(ULONG Address, ULONG Size, VOID * Data);
<pre>
<em>Ex:</em> rc = KeyManualPatch(Address, 4, &Data);
</pre>

</td><tr><td valign=top>
Pascal</td><td>
function KeyManualPatch(Address, Size: Longint; Data: Pointer): Boolean;
<pre>
<em>Ex:</em> rc := KeyManualPatch(Address, 4, @Data);
</pre>

</td><tr><td valign=top>
REXX</td><td>
rc = KeyManualPatch(Address, Size, Data)
<pre>
<em>Ex:</em> Address = KeyQueryProcAddressByName('MYDLL', 'MyFunction')
    call KeyManualPatch Address, 4, '90909090'
</pre>

</td></table>
<p>
  This function can be called to manually patch code or data,
  independent of data stored in CodePatch fields in the password
  string.
<p>
  When called, SecureIt checks whether the <b>Address</b> specified is a
  valid one, and writes data from the location the <b>Data</b> pointer
  points to to the <b>Address</b> specified.  <b>Size</b> bytes are
  changed by this operation.

<p>
  KeyManualPatch returns TRUE if the operation is successful, and
  FALSE otherwise.

<p>
  In REXX, the code is not compiled and it is not possible to patch REXX
  code using this API.  Instead, it is possible to obtain the address of
  an entry point in a DLL and patch it or a related address.  Do not
  attempt to patch any of the standard OS/2 DLLs in this manner!

<h3><A name="KeyManualDispatch">KeyManualDispatch - call executable code</h3>
<table width="100%" cellspacing=2 border=all>
<tr>
<td valign=top>C/C++</td>
<td>
BOOL _cdecl KeyManualDispatch(ULONG Address);
<pre>
<em>Ex:</em> rc = KeyManualDispatch(Address);
</pre>
</td><tr><td valign=top>
Pascal</td><td>
function KeyManualDispatch(Address: Longint): Boolean;
<pre>
<em>Ex:</em> rc := KeyManualDispatch(Address);
</pre>

</td><tr><td valign=top>
REXX</td><td>
rc = KeyManualDispatch(Address)
<pre>
<em>Ex:</em> Address = KeyQueryProcAddressByName('MYDLL', 'MyFunction')
    call KeyManualDispatch Address
</pre>

</td></table>
<p>
  Call this function to call the function at the <b>Address</b> specified.
  No checking is performed, and KeyManualDispatch always returns
  TRUE.  If an invalid address is specified, the program will crash.
<p>
  Calling KeyManualDispatch is equivalent to embedding a piece of
  assembler code in the program:
<pre>
  asm
    call dword ptr [Address]
  end;
</pre>

<p>
  In REXX, the code is not compiled and it is not possible to call a
  REXX function using this API.  Instead, it is possible to obtain the
  address of an entry point in a DLL and call it - provided the API
  expects no parameters.

<h3><A name="KeyManualJump">KeyManualJump - transfer control to address</h3>
<table width="100%" cellspacing=2 border=all>
<tr>
<td valign=top>C/C++</td>
<td>
VOID _cdecl KeyManualJump(ULONG Address);
<pre>
<em>Ex:</em> KeyManualJump(Address);
</pre>

</td><tr><td valign=top>
Pascal</td><td>
procedure KeyManualJump(Address: Longint);
<pre>
<em>Ex:</em> KeyManualJump(Address);
</pre>

</td><tr><td valign=top>
REXX</td><td>
call KeyManualJump Address
<pre>
<em>Ex:</em> Address = KeyQueryProcAddressByName('MYDLL', 'MyFunction')
    call KeyManualJump Address
</pre>

</td></table>
<p>
  Call this API to transfer control to <b>Address</b>.  No checking of
  the <b>Address</b> is performed, and control does not return to the
  calling routine.

<p>
  Calling KeyManualJump is equivalent to embedding a piece of
  assembler code in the program:
<pre>
  asm
    jmp dword ptr [Address]
  end;
</pre>

<p>
  In REXX, the code is not compiled and it is not possible to jump to
  REXX code using this API.  I cannot think of good reasons why you
  might want to, but it is possible to obtain the address of an entry
  point in a DLL and jump to it, never to return and a crash of the
  program a very likely consequence.

<h3><A name="KeyOverwriteCode">KeyOverwriteCode - overwrite executable code</h3>
<table width="100%" cellspacing=2 border=all>
<tr>
<td valign=top>C/C++</td>
<td>
VOID _cdecl KeyOverwriteCode(ULONG From, ULONG WithData);
<pre>
<em>Ex:</em> KeyOverwriteCode(Address, Data);
</pre>

</td><tr><td valign=top>
Pascal</td><td>
procedure KeyOverwriteCode(From, WithData: Pointer);
<pre>
<em>Ex:</em> KeyOverwriteCode(Address, Data);
</pre>

</td><tr><td valign=top>
REXX</td><td>
No REXX style entrypoint for this function

</td></table>
<p>
  This routine can be used to overwrite parts of your code with other
  code, or "crap" data and is useful for removing critical bits of
  code from the executable once they have been executed and should
  not be called again.
<p>
  KeyOverwriteCode overwrites all code from the <b>From</b> address
  specified up to the point where it was called from, with the data
  pointed to by the <b>Data</b> pointer.
<p>
  This can be useful when exiting a procedure that should only ever
  be executed once.  Even if someone tampers with your program and
  tries to execute the routine a second time, the program will
  probably crash instead of performing the desired function.
<p>
  Note, that you obviously need to be very careful when calling this
  function - it ignores many safeguards the operating system or the
  compiler may enforce on where you can write data.

<h3><A name="KeyAllowDebugger">KeyAllowDebugger - disable anti debugger code</h3>
<table width="100%" cellspacing=2 border=all>
<tr>
<td valign=top>C/C++</td>
<td>
VOID _cdecl KeyAllowDebugger(VOID);
<pre>
<em>Ex:</em> KeyAllowDebugger();
</pre>

</td><tr><td valign=top>
Pascal</td><td>
procedure KeyAllowDebugger;
<pre>
<em>Ex:</em> KeyAllowDebugger;
</pre>

</td><tr><td valign=top>
REXX</td><td>
call KeyAllowDebugger
<pre>
<em>Ex:</em> call KeyAllowDebugger
</pre>

</td></table>
<p>
  SecureIt employs includes some anti-debugger code, which helps
  dissuade pirates from cracking your software.  Since this code will
  affect your debugger as well when you try to debug a program using
  the SecureIt protection, this function is available for you to call
  at the beginning of your program while you are still testing the
  code.

<p>
  In REXX, it is probably not required to call this for your debugger to
  work at source level, although the anti-debugging code is still in
  effect if a cracker attempts to dig into the SecureIt REXX extension
  DLL.

<p>
  Do remember to remove this call once you have succesfully debugged your
  code, for example by enclosing the call in a conditional statement
  block:

<p>
  Pascal:
<pre>
  {$IFDEF TEST}
  KeyAllowDebugger;
  {$ENDIF}
</pre><p>

  C/C++:
<pre>
  #ifdef test
  KeyAllowDebugger();
  #endif
</pre><p>

<h2><a name="rexxapi">REXX specific functions</h2>
<p>
  Two REXX specific functions are available, due to the fact that REXX
  is an interpreted language and some of the advanced SecureIt features
  are not applicable for an interpreted language: CallBack and
  CodePatch.  In order for you to be able to use this functionality
  anyway, some of your code should reside in an external DLL file
  written in a compiled language such as C or Pascal; code in this DLL
  can then be called or patched indirectly from your REXX program.

<p>
  For more information about REXX specific issues, please refer to the
  section about <a href="compiler.htm#rexx">REXX</a> in the <a
  href="compiler.htm">compiler considerations</a> chapter of this
  document.

<p>
  The following two functions can be used to obtain the addresses of
  published entrypoints in such DLLs, and addresses obtained in this way
  can then be used for callback or codepatch functions.

<h3><A name="KeyQueryProcAddressByName">KeyQueryProcAddressByName - get
address of entry point</h3>
<table width="100%" cellspacing=2 border=all>
<tr><td valign=top>
REXX</td><td>
Address = KeyQueryProcAddressByName(DLLName, EntryPointName)
<pre>
<em>Ex:</em> Address = KeyQueryProcAddressByName('MYDLL', 'MyFunction')
</pre>

</td></table>
<p>
  The <b>DLLName</b> parameter should hold the name of the DLL from
  which you want to extract an address.  This should normally be
  specified as a name without extension, which causes OS/2's LIBPATH
  variable to be searched for the DLL.  If the .DLL extension is used,
  the name is interpreted as fully qualified and will not perform any
  searches for the DLL.  If the DLL is not already loaded into memory,
  this API will do so prior to returning to the REXX program.

<p>
  The <b>EntryPointName</b> parameter should specify the name of an
  exported entrypoint in the DLL.

<p>
  The address returned from this API is a hex string; if you want to
  manipulate it (adding an offset, for example), you should convert it
  to a decimal value using the REXX X2D function first, and use the D2X
  function to convert it back to a hex string before passing the address
  to another SecureIt API.

<p>
  If the specified entrypoint does not exist, or the DLL cannot be
  found, an address of 00000000 is returned.


<h3><A name="KeyQueryProcAddressByOrdinal">KeyQueryProcAddressByOrdinal - get
address of entry point</h3>
<table width="100%" cellspacing=2 border=all>
<tr><td valign=top>
REXX</td><td>
Address = KeyQueryProcAddressByOrdinal(DLLName, Number)
<pre>
<em>Ex:</em> Address = KeyQueryProcAddressByOrdinal('MYDLL', 17)
</pre>

</td></table>
<p>
  The <b>DLLName</b> parameter should hold the name of the DLL from
  which you want to extract an address.  This should normally be
  specified as a name without extension, which causes OS/2's LIBPATH
  variable to be searched for the DLL.  If the .DLL extension is used,
  the name is interpreted as fully qualified and will not perform any
  searches for the DLL.  If the DLL is not already loaded into memory,
  this API will do so prior to returning to the REXX program.

<p>
  The <b>Number</b> parameter should specify the ordinal number of an
  exported entrypoint in the DLL.

<p>
  The address returned from this API is a hex string; if you want to
  manipulate it (adding an offset, for example), you should convert it
  to a decimal value using the REXX X2D function first, and use the D2X
  function to convert it back to a hex string before passing the address
  to another SecureIt API.

<p>
  If the specified entrypoint does not exist, or the DLL cannot be
  found, an address of 00000000 is returned.


</body>
</html>
