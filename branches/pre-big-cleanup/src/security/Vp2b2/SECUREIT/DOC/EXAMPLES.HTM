<HTML>
<HEAD>
  <TITLE>SecureIt - Example programs</TITLE>
</HEAD>
<body background="backgrnd.gif" onLoad="parent.index.location.href='examples.inx'; return true">

<h1><a name="top">Example programs</h1>
<p>
  The example programs are provided with both Pascal, C and REXX source
  code, although the CLOCK example is only available in Pascal.

<p>
  The example source code (*.C, *.PAS and *.CMD) as well as parameter
  files for MakeKey (*.KEY) and GenData (*.GEN) and precompiled
  executable versions can be found in the PASCAL\SAMPLE, BC\SAMPLE,
  IBMCPP\SAMPLE and REXX\SAMPLE subdirectories.

<p>
  The example programs can be pirated, given enough effort. This is not
  because SecureIt does not work, but because the programs are so simple
  that it is possible to figure out what they should do even in those
  cases where vital information is stored in the password. This is of
  course a lesson: Do not rely solely on a good protection scheme; you
  need to think about the way you use it in order to get maximum
  protection.

<p>
  For simplicity's sake, all of the examples contain a valid name and
  password and simply call <a
  href="api.htm#KeySetNamePsw">KeySetNamePsw</a> with the password hard
  coded. This is of course not the way you should write your program,
  but serves well enough for demonstration purposes.

<p>
  Note, that the password strings you generate with the .KEY files in
  the SAMPLE subdirectories will be different from the ones you find in
  the examples.  This is due to the fact that <a
  href="makekey.htm">MakeKey</a> is personalised, and passwords
  generated for the same name, using the same .KEY file, will be
  different for each user of SecureIt.

<p>

<h2><a name="prot1">PROT1.PAS / PROT1.C - Minimal SecureIt protection</h2>
<p>
    This program uses SecureIt, but to the smallest extent possible and
    is not secure, since the password does not contain any information
    other than validity checks.

<p>
    Do note, that this program is still protected better than the
    majority of generally available shareware programs, since it is not
    immediately possible to generate a valid password string based on
    what the checking routine does.

<p>
    It is however very possible to make a simple patch for this program,
    to have it perform registered-only functions without having a valid
    password.

<p>
    The setup for this example is compatible with SecureIt v1.0, and
    v1.0 passwords will work with this program as well.

<p>
    As for the other examples, the steps that need to be taken to build
    the final executable - irrespective of language - are
<ul>
  <li>Generate a data blob using GenData with the appropriate setup,
      Prot1.Gen for this example:
<pre>
GENDATA Prot1
</pre>
  <li>Generate a valid password using one of the flavours of MakeKey and
      the appropriate setup, Prot1.Key for this example:
<pre>
MKTXT Prot1 My UserName
</pre>
  <li>Compile and link the executable (Does not apply to REXX).
</ul>

<p>
    The GenData setup file Prot1.Gen is very simple for this example:
<pre>
;
; Setup file for generating data blob for SecureIt v2
;
; Prot1 example, using default setup

KeyLength       64
GetRandom       Pseudo
Format          Pascal
OutputTo        Prot1.inc

; No user strings

; No locked-out serial numbers

; No date-limited serial numbers
</pre>

<h2><a name="prot2">PROT2.PAS / PROT2.C - Slightly better</h2>
<p>
    This program is based on PROT1, but uses a CallBack function for
    better protection.  The Registered variable is not set explicitly
    except in the IsRegistered procedure, which is only called from the
    registration check (the address is embedded in the password string)
    and so is hard for a potential pirate to find.  However, we are
    still quite a way away from being perfect.

<p>
    To generate keys for PROT2, look at PROT2.KEY which is used
    as input to the MakeKey program.  The interesting line in this
    file is line 10:

<pre>
Callback  1007C  (The actual value differs for each compiler used)
</pre>

<p>
    This line causes control to be transfered to address 1007C (in hex)
    when the key has been verified - and this is the address of the
    IsRegistered routine.  You can get this address from the map file
    your compiler generated, or by looking inside the debugger.

<p>
    An interesting point is that optimizing compilers are fooled and may
    not realise that the Registered variable changes - and so removes any
    code that is only executed when Registered is True!  If you have a
    compiler that performs these kinds of optimisations, you may have to
    disable optimisations for the security module, or write your program
    slightly differently.

<p>
    Note the use of the <a
    href="api.htm#KeyGetregisteredName">KeyGetregisteredName</a> API
    used to retrieve the name of the registered user.

<p>
    Since the setup regarding embedded serial numbers and RSA-encrypted
    passwords did not change from the Prot1 example, a separate .GEN,
    .INC and .RSA file is not included for this example - we simply use
    the ones from Prot1.
<p>
    For REXX, it is not immediately possible to make a callback
    definition.  REXX programs are interpreted rather than compiler
    (this is true for advanced REXX environments like VX-REXX as well)
    and calling tokenized REXX is not possible.

<p>
    Instead, this and the following examples uses an external DLL which
    is useable with REXX to demonstrate CallBack and CodePatch fields
    from REXX.  The Pascal source code for the PROT2RX DLL used by this
    example can be found in the REXX\SAMPLE directory.

<p>
    This DLL is very simple: It defines a single exported function,
    RxFunc21, which returns the value of a static variable Registered,
    which is initialised to be FALSE.  It also defines a non-exported
    entry point IsRegistered, which - as in the C and Pascal examples -
    are to be called from within KeyCheck and sets the value of this
    variable to TRUE.

<p>
    However, since the REXX DLL is a DLL, we have to use the relative
    call and patch methods not demonstrated until the PROT5 example for
    the other languages; please refer to the <a href="#prot5">PROT5</a>
    example and the relevant API calls for an in-depth explanation of
    this.

<p>

<h2><a name="prot3">PROT3.PAS / PROT3.C - Better still</h2>
<p>
    This program also expands on the previous example and implements the
    same features as PROT2, plus more.  One obvious weakness of PROT2 is
    that the Registered variable is the only real security we have - if a
    pirate forces it to be TRUE, all functions in the program are
    enabled.  We also want to use some of the strong features of SecureIt:
    RSA-encrypted passwords and embedded serial numbers.

<p>
    To address this, a valid password for PROT3 includes a bit of code (4
    bytes) which is inserted into the RegisteredOnly procedure once the
    code has been validated.

<p>
    This is done by specifying
<pre>
CodePatch 10006 90909090
</pre>
<p>
    in the MAKEKEY setup file, PROT3.KEY.  This line instructs SecureIt
    to *change* the code at 10006 (hex) to be 90909090 (also hex). Since
    90 is the op-code for the NOP (No Operation) assembler instruction,
    this change simply causes 4 bytes to be changed from doing
    "something" to doing "nothing".

<p>
    The code that is changed is the code written in in-line assembler
    (the asm..end block), which is quite simple: It sets the value of the
    eax register to 0 and returns - and thus the code meant for
    registered users is never executed unless this code is modified. The
    procedure for getting the address of the code block is similar to the
    process outlined in the PROT2 example.  Note, that the address of the
    IsRegistered routine has changed since PROT2 because of the code
    change; this address must be changed in the KEY file as well to make
    the relevant entry read
<pre>
Callback 10080
</pre>

<p>
    The strength of this kind of protection is that the address of the
    code and the value that needs to be inserted is not part of the
    standard package: Only users with a valid password have this
    information available.

<p>
    Last, we want to enable RSA encryption of the password and serial
    numbers in the password string; to do this, two modifications are
    required.  First, we need to modify the .GEN parameter file for
    GenData to save the RSA key used to encrypt the data in a way so
    MakeKey can use the same key for encrypting the passwords:
<pre>
;
; Setup file for generating data blob for SecureIt v2
;
; Prot3 example

KeyLength         128
GetRandom         Pseudo
Format            Pascal
OutputTo          Prot3.inc
ReadRSAKeyFrom    Prot3.RSA
SaveRSAKeyTo      Prot3.RSA

; No user strings

; No locked-out serial numbers

; No date-limited serial numbers
</pre>

<p>
    Next, the source code itself needs to be modified to reflect the
    change in password setup; simply change the Boolean parameters to
    the <a href="api.htm#KeySetup">KeySetup</a> API.

<p>
    Note: The IBM VAC++ version of this example does not include code
    patching. It does not support embedded assembler instructions and
    reproducing this example without that is not within the scope of
    this document.  For an example of code patching using IBM VAC++,
    please refer to the Prot5 example.

<p>
    REXX note: The REXX version of this example again uses an external
    DLL for patching and callbacks.  The source code for the PROT3RX DLL
    is in the REXX\SAMPLE directory.

<p>
    This version of the DLL defines two external entry points: RxFunc31
    (as was the case in the Prot2 example) and RxFunc32, which outputs
    the "registered" message on screen, given the name and serial
    numbers as parameters.  The reason for the nondescript names is to
    give away as little information as possible - in the source code,
    the functions have much more descriptive names.

<p>
    The reason why the names of the entrypoints are different (RxFunc21
    and RxFunc31 for example) for the different examples is that the
    REXX processor appears to be confused when more than one DLL defines
    the same function.  Thus, if I has just used RxFunc1 for all of the
    similar entry points in the different DLLs, after running Prot2,
    Prot3 would no longer run and vice versa.  Go figure.
<p>

<h2><a name="prot4">PROT4.PAS / PROT4.C - Encrypted strings and serial
numbers that expire</h2>
<p>
    Again modifying the previous example, PROT4 moves all sensitive
    strings in the program into the data blob generated by GenData, and
    defines a range of serial numbers to expire.

<p>
    Having this extra layer of protection means, that it is impossible
    to do a plaintext search for crucial "unregistered" or "expired"
    strings, which makes it much more difficult to attack the program.

<p>
    In order to encrypt the critical text strings (in the case of the
    example, all of them) they need to be defined as UserString fields
    in the .GEN setup file for this example.

<p>
    Next, we want the ability to give away demonstration or limited
    licences that expire some time in the future.  The thought is that
    the user is asked to enter his name and password; if he does not
    have one, a default demo licence key will be used.  In the example,
    this is done by generating a key for a user called "Demonstration
    Licence" containing a serial number that expires on 1 Dec 1997.

<p>
    The GenData setup file for the example now looks like this:
<pre>
;
; Setup file for generating data blob for SecureIt v2
;
; Prot4 example

KeyLength         128
GetRandom         Pseudo
Format            Pascal
OutputTo          Prot4.inc
ReadRSAKeyFrom    Prot4.RSA
SaveRSAKeyTo      Prot4.RSA

; User strings

;               Strings displayed in RegisteredOnly function

 0 UserString   Program registered to %s
   UserStringQ "        Serial Number %8.8x"
 2 UserString   This function is only available to registered users,
 3 userString   so you must be one of those...

;               Strings displayed when testing key

 4 UserString   Key entered is valid
 5 UserString   Program is unregistered
 6 UserString   The serial number used is expired; please get an upgrade
 7 userString   This key is locked and cannot be used!

;               Name and password to use for "demo version"

 8 UserString   Demonstration Licence
 9 UserString   zljAQ7wtfbd9xWHJmAHgHjjVCp7VILcUw3oU41NK7XZIBHHd


; Locked-out serial numbers

SNLockOut  0007F993
SNLockOut  0007E981

; Date-limited serial numbers

SNDateLock 00071000 0007E000  1 Dec 1997
</pre>

<p>
    In order to generate the data blob for this example, we obviously
    need to do things in a slightly different order from the usual one.
    Since we want to include a valid demonstration key in the executable
    itself, via the data generated by GenData, we need to first run
    MakeKey to generate the password with the desired (expiring) serial
    number.

<p>
    With this in hand, we can go on to insert the name and password in
    the .GEN file as shown above, generate the include file by executing
    GenData, and finally compiling the executable program itself.

<p>
    The sample program does not actually attempt to ask the user for a
    valid key first; it simply uses the registration key embedded in the
    data blob.  It does this by calling the <a
    href="api.htm#KeyGetUserStringP">KeyGetUserStringP</a> API twice to
    get both user name and passwords, and calls <a
    href="api.htm#KeySetNamePswP">KeySetNamePswP</a> with these strings
    as the parameter.

<p>
    <b>This is a safe methodology!</b>  Since the password string is RSA
    encrypted, it is highly unlikely that a pirate will be able to
    generate a valid password string with a non-expiring serial number
    in it, even though he already has a valid password.  Of course,
    since the program does not really do anything, it is not very
    interesting to crack :)

<p>
    Note: The IBM VAC++ version of this example does not do any code
    patching.

<p>
    REXX note: This example, as Prot2 and Prot3, uses an external DLL to
    demonstrate patching and callbacks.  The methodology used is very
    straightforward; please refer to the source code for PROT4RX.DLL in
    REXX\SAMPLE\PROT4RX.PAS for more information.

<p>

<h2><a name="prot5">PROT5.PAS / PROT5.C - A sensible example</h2>
<p>
    PROT4 may be quite well protected, but suffers from the drawback
    that the passwords are valid for only one particular version of your
    program.  This is because the addresses of callback and patch
    functions are hard coded into the password string, and it is
    unlikely that those absolute addresses do not change between
    versions.

<p>
    This example removes that concern while maintaining the good
    security provided by Patch and CallBack fields, and also extends the
    security of the program by a number of other methods.

<p>
    You can of course try to organise your code in such a way that the
    entry points of callback functions and functions that are patched
    never change their addresses - but this is not always possible.

<p>
    What *is* possible is to prevent certain segments or parts of code
    from changing their addresses.  If you can do this, and establish a
    fixed point in the code that is unlikely to change between versions,
    you can still make use of CallBack and Patch functions without
    having to send out new keys every time a new version is released.

<p>
    In the Prot5 example, this concept is illustrated.  The empty
    FixedLocation procedure does nothing except being a placeholder to
    which address offsets can be added to calculate absolute addresses
    within the program.  The CodePatch and CallBack values stored in the
    password (as defined in the setup file Prot5.Key) are the offsets,
    or distances between, the FixedLocation procedure and the addresses
    we are really interested in.  By using the <a
    href="api.htm#KeySetCallOffsets">KeySetCallOffsets</a> and <a
    href="api.htm#KeySetPatchOffsets">KeySetPatchOffsets</a> API calls,
    we tell SecureIt to add an absolute address before using the values
    in those fields.

<p>
    Before going off and verifying the password, we will attempt to
    establish that the SecureIt DLL has not been tampered with in any
    way.  The first part of this verification is done in the
    VerifySecureItIntegrity function, which returns FALSE if SecureIt
    does not work as expected - the program should then take appropriate
    action.  The check consists of two parts that both serve to verify
    that SecureIt still works as expected.

<p>
    First, we define an obviously invalid name/password combination of
    "Test User" and "Hello World", which we try to validate with a call
    to the <a href="api.htm#KeyCheck">KeyCheck</a> API.  This check
    should obviously fail, or it is likely that someone has tampered
    with SecureIt to prevent the <a href="api.htm#KeyCheck">KeyCheck</a>
    function from ever failing.

<p>
    Having passed the second check, we use a valid name and password
    combination stored in the data blob generated by GenData.  This
    password however contains a serial number of 00000010, which is in a
    range that expired in 1990, and this password should also fail.  If
    it does not, it is likely that someone has set the clock back, or
    that the SecureIt DLL has somehow been modified.  In a real life
    situation, the password used to check this function should not be
    one generated using the standard .KEY file.  Since we are not
    interested in ever using this key, you can make a .KEY file that
    uses the same .RSA file as the "real" key but does not include any
    of the CallBack, CodePatch or UserValue fields specified in the real
    key to achieve the same effect.

<p>
    The third and last check takes place in the IsRegistered function,
    which is called from within the KeyCheck function if the specified
    password (the real one) is valid.  Rather than just set the value of
    the Registered variable to TRUE as in the other examples, it
    calculates the checksum of the SecureIt DLL by using the
    <a href="api.htm#KeyGetFileChecksum">KeyGetFileChecksum</a> API and
    compares this value against the real checksum stored in a user field
    in the password.  Only if these values match is the Registered
    variable set to True.

<p>
    The GenData setup file for this example looks like this:
<pre>
;
; Setup file for generating data blob for SecureIt v2
;
; Prot5 example

KeyLength         128
GetRandom         Pseudo
Format            Pascal
OutputTo          Prot5.inc
ReadRSAKeyFrom    Prot5.RSA
SaveRSAKeyTo      Prot5.RSA

; User strings

;               Strings displayed in RegisteredOnly function

 0 UserString   Program registered to %s
   UserStringQ "       Serial Number %8.8x"
 2 UserString   This function is only available to registered users,
 3 userString   so you must be one of those...

;               Strings displayed when testing key

 4 UserString   Key entered is valid
 5 UserString   Program is unregistered
 6 UserString   The serial number used is expired; please get an upgrade
 7 userString   This key is locked and cannot be used!

;               Name and password to use for testing integrity
;               The serial number is 0010, so it has expired

 8 UserString   Test User
 9 UserString   KoV8GER2Qgf2ApH-74jQ4W9KHtV5SI45EDMUQ4Ve0gNHbCvjstAgIsDtkQ7oNT7kguPRmyTD

;               Strings displayed when serial number will expire

10 UserStringQ "  This licence will expire on "

; Locked-out serial numbers

SNLockOut  0007F993
SNLockOut  0007E981

; Date-limited serial numbers

SNDateLock 00000010 00000011  1 Jan 1990
SNDateLock 00071000 0007E000  1 Dec 1997
</pre>

<p>
    Note: Since the IBM VAC++ compiler does not support embedded
    assembler instructions, the CodePatch performed for this compiler is
    slightly different.  In the IsRegistered function, we intentionally
    make the code queriy the value of User Value 3 instead of User Value 1
    containing the checksum, and the CodePatch changes this back so the
    correct User Value is queried.  The .KEY file contains the details
    of this.

<p>
    REXX note: The REXX example does not verify the checksum of the
    RXSI2.DLL file in the IsRegistered routine.  The C and Pascal
    versions can do this because they can call the SecureIt function
    required to query a user value - the IsRegistered function located
    in the PROT4RX.DLL cannot call the REXX function to do the same.
<p>

<h2><a name="clock">CLOCK.PAS - A real example</h2>
<p>
    This example program illustrates SecureIt used in a more realistic
    environment than that presented in the previous examples.  The
    program implements a simple clock in OS/2 PM, and registered users
    can make it show a digital clock as well.
<p>
    The full Pascal source code for the program can be found in
    PASCAL\SAMPLE\CLOCK.PAS, and illustrates some of the points made
    previously, both in the examples and in the
    <a href="advice.htm">General Advise</a> section.
<p>
    Even if Pascal is not your force, you can probably gain something by
    just reading these comments and looking at the source code - it is
    not really very different from C.
<p>

<h3><a name="conditionals">The Conditional Defines</h3>
<p>
    Starting at the top, the code contains a comment describing the
    conditional defines that have an effect on the way the program works.
    The two that affect the way Clock works are SHIP and TEST. When the
    SHIP conditional is defined, the code will be compiled using all of
    the SecureIt function calls and when SHIP is not defined, the code
    will rely on wrapper functions to achieve the same effect.  This is
    to avoid having to produce a new valid keyfile to be able to run the
    code every time it changes during development.

<p>
    The TEST conditional should be enabled when the program is still
    being tested in the debugger and is used to determine whether the
    <a href="api.htm#KeyAllowDebugger">KeyAllowDebugger</a> entry point
    should be called on startup.  If this API is not called, the
    debugger will hang, crash, or otherwise behave strangely - this is
    the effect we want to impose on would-be pirates, not ourselves
    while debugging the code.
<p>

<h3><a name="constants">Types and Constant declarations</h3>
<p>
    A bit further down, the Window type is defined - this is just the
    application framework being set up, and has nothing to do with the
    way SecureIt is used, so we will ignore that for the moment.
<p>
    Following the type definitions, a large block of constants are
    declared.  In reality, most of them are "typed constants", which
    means that they are just pre-initialised variables that can be
    changed by the program when required.

<p>
    The most interesting constants are the ones with names si_*.  These
    are used as indices into the strings stored in the datablob
    generated by GenData and make it easier to use the right strings in
    the right places.

<p>
    Following the constants, the Numbers array is defined.  This
    array defines which of the elements in the 7-segment LCD style
    display are lit for each of the 10 numerics 0 thru 9.  In the
    shipping version, this array has been encrypted with a random
    number sequence, the seed of which is stored in a user value in the
    password.

<p>
    Last, a set of unencrypted constants are defined for the
    non-shipping version of the code (The {$IFNDEF SHIP} section).
    This const declaration section contains definitions that will be
    used in place of information stored in the password, such as the
    address of a CallBack routine, the real (unencoded) Numbers array,
    and the two user values that will eventually be stored in the
    password.  Having these values available means that we can implement
    security early on, but do not have to generate new passwords every
    time the code changes.

<p>
<h3><a name="code">Digging into the code</h3>
<p>
    The first routine of interest is the GetUserValue function, which
    is a wrapper around the <a
    href="api.htm#KeyQueryUserValue">KeyQueryUserValue</a> API in
    SecureIt when the Clock is compiled in the shipping version, but
    which just returns the user value from an array while we are still
    testing the software.

<p>
    The next routine is CheckRegistration, which reads the name and
    password from the Clock.Ini file and sets the Registered state
    based on the information stored there.

<p>
    Then, the dialog function for the Registration Dialog can be found
    (DlgRegister).  This function will be called as the dialog function
    when we display the dialog prompted by Alt-R or by selecting the
    Register menu item.

<p>
    During initialisation of the dialog (handling the WM_INITDLG
    message), the Name and Password labels are descrambled and inserted
    into the dialog, as is the dialog title string.  Once the strings
    have been descrambled and used, they are re-scrambled so the code
    will work on a second pass as well.
<br>
    The local procedure HandleOKButton handles the situation where the
    user has entered a value into the Name and Password entry fields,
    and has clicked the OK button.  The procedure gets the strings from
    the entry fields, calls <a
    href="api.htm#KeySetNamePsw">KeySetNamePsw</a> in SecureIt, and checks
    whether they ar good values.  If they are, they are written
    (encoded) to the Clock Ini file - if they are not, the code in
    HandleOKButton is *overwritten* by a call to <a
    href="api.htm#KeyOverwriteCode">KeyOverwriteCode</a>.
    Since the code itself (see later) ensures that the dialog will
    never be called again once an invalid password has been entered,
    this seems a reasonable precaution.

<p>
    The ClockApplication.Init constructor, which is called at the very
    beginning of the program, initialises the Clock frame and client
    windows.  Just prior to doing so, it calls KeySetup with a setup
    matched by that defined in the Clock.KEY file, including the
    arbitrarily chosen Version Code value of 093341 (hex) that must be
    matched by the version stored inside the password for it to be
    valid.

<p>
    In TClockWindow.DrawNumber, a single number is drawn using the
    7-segment display defined in the local SevenSeg array.  A single
    value used in a loop and to count the number of elements required is
    stored in a byt of one of the user fields - again, if no valid
    password is available, the pirate needs to guess the value required
    to make this work (and change the code appropriately).

<p>
    The TClockWindow.DrawColon method draws a colon at the designated
    location, and again uses a value from one of the user fields to do
    some of the setup.

<p>
    Procedure DummyBeforeShowDigital is empty, and is just what the name
    suggests: A dummy placeholder procedure that will not move relative
    to the DoShowDigital function a bit later in the code. This way, we
    can just store the difference in addresses between the two
    procedures in the password, and not be worried about the code moving
    slightly when we change something somewhere else.  The absolute
    address of DummyBeforeShowDigital that should be added before making
    the callback will be set using a call to the KeySetCallOffsets
    function before the password string is validated.

<p>
    TClockWindow.HandleMessage is where the main action takes place,
    since this is the message handling function for the main PM client
    window.  The local DoShowDigital function includes some code that
    needs to be changed for the procedure to work properly (the bits
    inside the asm..end statement), and thus the need for the
    DummyBeforeShowDigital procedure mentioned previously.  The
    CodePatch field (as defined in Clock.Key) in the password contains
    the offset from the dummy procedure and a set of bytes to
    patch on top of the wrong code - two NOPs followed by a JMP
    instruction that simply tells the machine to skip the inserted code
    and go directly to the "real" code.

<p>
    The three messages of interest are wm_Create, cmRegister and
    cm_CheckReg.  In the wm_Create handler, the usual window
    initialisation code is executed, after which a cm_CheckReg message
    is dispatched, with the value of the Registered variable as the
    parameter.

<p>
    In the cm_CheckReg message handler, it is verified that this
    parameter is indeed 1 (The integer value of TRUE).  If it is, the
    InitialiseRegistered procedure is called, either indirectly through
    a call to <a href="api.htm#KeyDispatch">KeyDispatch</a> in the
    shipping version, or directly using a call to the procedure while we
    are still testing the code.

<p>
    Finally, the cmRegister message is posted when the user pressed
    Alt-R or selects the Register item from the menu.  This message
    causes the Registration Dialog to be shown (as discussed earlier).
    If the result of that is that the code is not registered, a
    cm_CheckReg message is posted and no further action is taken.  If
    the program is still not registered after this (ie a wrong password
    was entered), the Register menu item is disabled and an error
    message is displayed in a message box.  The text displayed in the
    error message - like other "sensitive" strings displayed in the
    program - are of course included in the RSA-encrypted data blob
    generated by GenData for this example.

<p>
    The InitialiseRegistered procedure towards the end of the program
    is only ever called from the cm_CheckReg message handler above, and
    only through a <a href="api.htm#KeyDispatch">KeyDispatch</a> call in
    the shipping version.  It enables all of the registered functions
    (that is, it enables the "Digital" menu item).  It then moves on to
    manually apply the code patch to the DoShowDigital procedure, and
    finally decodes the Number array using a value stored in User Value
    1.

<p>
    This code is somewhat complicated, because it includes code to find
    the encoded version of the Numbers array if the SHIP conditional is
    not defined, but is otherwise quite simple.

<p>
    A feature that has not been used in any of the other examples is a
    Checked Log file.  This is enabled by including the
    <a href="makekey.htm#reglogfile">RegLogFile</a> keyword in the .KEY
    file.  If the log file does not exist, the makekey programs refuse
    to create valid passwords however - you need to create an empty one
    first by calling MkTxt with a /C parameter, or by clicking "Apply"
    in MkPM when you have entered a non-existing filename in the
    RegLogFile entry field.

<h3><a name="clockcheckedlog">The Checked Log File</h3>
<p>
    After the MakeKey program has been used to generate the two
    passwords supplied with the clock example (one that expires and one
    that does not), the checked log file Clock.Reg looks like this:
<pre>
SecureIt Checked Log File

Default SecureIt Protected Program v1.0
For internal use only

 Date and Time      Serial    Name of user                              Password
 12-12-97 22:43:25  00017010  Allan M                                   ejblDBmqBrtAJzL5WFY8aLaIU0EyXQMn-+PVw-6q0lkd4jChX4rBvwkt6iixl6TIdnzVs5oE
 12-12-97 22:43:50  12345678  Allan M                                   F0+fR2t+fVy4SdhOsCXRc3qSmchtdMZ4clXHHLZYWj6nOhKWn25Gntybcowsmag8Jm76Gez2

---
Internal CheckSum on next line; do NOT modify this file
D4E99F1E
</pre>

<p>
    You may need to scroll a bit to the right to see the password strings,
    since the Name column occupies 40 characters :-)

<h3><a name="clockgd">The GenData setup file</h3>
<p>
    The GenData setup file for this example, Clock.Gen, looks like this:
<pre>
;
; Setup file for generating data blob for SecureIt v2
;
; Clock example

KeyLength         128
GetRandom         Pseudo
Format            Pascal
OutputTo          Clock.inc
ReadRSAKeyFrom    Clock.RSA
SaveRSAKeyTo      Clock.RSA

;               Strings displayed in error window on wrong password

0 UserString   The name and password entered do not match and the registration screen has been disabled.  Please restart the program if you wish to retry the registration process
1 UserString   Registration error

;               Strings used as labels in the registration dialog

2 UserString   Name
3 UserString   Password
4 UserString   Please enter registration details

;              Strings for dialog displayed when user presses F1

5 UserString   Help?!?
6 UserStringQ "You expect HELP???

... :-)"

;              String displayed if password is expired

7 UserString   The licence for this password has expired. Please contact the author to extend the licence.


; Locked-out serial numbers

SNLockOut  0007F993
SNLockOut  0007E981

; Date-limited serial numbers

SNDateLock 00000010 00000011  1 Jan 1990
SNDateLock 00017000 00020000  1 Dec 1997
</pre>

<h3><a name="clockmk">The MakeKey setup file</h3>
<p>
    - and the MakeKey setup file for this example, Clock.Key, looks like this:
<pre>
;
; Key definition file for SecureIt
; MAKEKEY setup file for CLOCK keys
;

; ----[ PROTECTION FIELDS ]----

; Callback field: InitialiseRegistered
; The value stored here is relative to TClockWind.RotateFigure
Callback   00000134

; CodePatch using relative address and code for DoShowDigital
CodePatch  00000163 8BE507EB

; User value used instead of various constants in the code
UserValue  445B93F8

; Version code (3 byte word) for which the key is valid
Version 093341

; RSA-encrypt the password
RSAEncodePassword 1

; The RSA key to use can be found in...
RSAKeyFile Clock.RSA

; Include a serial number in the password
UseSerialNumber 1

; Next serial number to use
NextSerialNumber 12345678

; Automatically increment serial number
IncrementSerialNumber 1

; Disregard high-ascii characters in checksum
HighAsciiCounts 0

; ----[ OPTIONAL FIELDS ]----

; ScreenOutput determines whether key generator writes to screen
; Valid values are 0 and 1
ScreenOutput 1

; LogFile specifies which logfile to use, if any
LogFile Clock.log

; Debug (either 0 or 1) defines whether detailed info is displayed
Debug 0

; Use a Checked Log File to keep track of passwords generated
RegLogFile Clock.Reg
</pre>


</body>
</html>
