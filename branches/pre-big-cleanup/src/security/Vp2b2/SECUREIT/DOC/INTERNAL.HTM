<HTML>
<HEAD>
  <TITLE>SecureIt - Internals</TITLE>
</HEAD>
<body background="backgrnd.gif" onLoad="parent.index.location.href='internal.inx'; return true">

<h1>SecureIt - Internals</h1>
<p>
  The source code for SecureIt is not part of this package, primarily
  because I want to sell the program in the future as well, and do not
  wish clones or derivates based on my source code to appear.
<p>
  Still, I wish you as a user of SecureIt to have a high level of
  confidence in SecureIt, and will attempt to cover relevant technical
  internal bits in this document - or answer your questions by e-mail,
  if there is something not covered here that you wish to know.


<h2><a name="insecure">Not so secure API calls</h2>
<p>
  A very important point that you must be aware of when using SecureIt
  in your program is that parts of the SecureIt protection is not as
  good as I would like it to be - because there is no way of making it
  more secure.
<p>
  The unsafe parts all have to do with those parts of SecureIt that
  subtract rather than add information to your program, namely the
  serial number expirations and lockouts.
<p>

<h3><a name="history">A bit of history and technical details</h3>
<p>
  In v1.0 of SecureIt, I did not supply functions to cater for these,
  because I considered it to be impossible to make a decent
  implementation, and providing an unsafe implementation would be to
  give you a false sense of security - not my way of doing business.
<p>
  However, a user of SecureIt made me realise that there is a way in
  which it is possible to make these very desirable features available,
  and even implement them in a manner that is quite secure.  The key to
  doing this is asymmetric encryption of both code and data using the
  RSA algorithm: <a href="gendata.htm">GenData</a>.
<p>

<h3><a name="how">How it can be secure</h3>
<p>
  You may have noticed that <a href="gendata.htm">GenData</a> seems to
  store more data in the include files than you specify in the .GEN
  file.  This is correct: <a href="gendata.htm">GenData</a> includes
  about 400 bytes of executable code, code which handles the issues to
  do with serial number validation, lockout and expiry - and code to
  decode and localise your user strings embedded in the RSA encrypted
  data.
<p>
  The code, which consists of 5 small functions written in assembler, is
  accessed through a single entrypoint inside the SecureIt code that
  transfers control to the code in question.  Since the embedded code
  not only checks serial numbers but also does something the cracker
  wants the program to keep doing, namely return user strings and
  perform part of the password decoding, simply removing the call to
  this code from the SecureIt DLL will not work.
<p>
  The function for checking whether a particular serial number is out of
  date is particularly tricky.  Since the code is not part of the
  executable, it cannot directly make any OS/2 API calls to retrieve the
  current date.  The obvious choice therefore is to pass the current
  date as a parameter to the checking routine, but this is obviously
  unsafe, since a cracker could then patch the SecureIt DLL to always
  pass a very early date, thus causing the date check to never fail.
<p>
  Instead, SecureIt passes the addresses of the OS/2 API functions
  DosLoadModule and DosQueryProcAddress to the routine.  This allows
  the code to (with a bit of work) obtain the address of the
  DosGetDateTime API, call it, and compare the value returned to the
  expiration date for the serial number given.  Since this all happens
  inside encrypted code, it cannot be changed and thus cannot be worked
  around.
<p>

<h3><a name="what">What is insecure about it</h3>
<p>
  The checking routine mentioned above updates a global status variable
  that contains the current serial number and the state of the serial
  number.   If this check fails, the
  <a href="api.htm#KeyCheck">KeyCheck</a> function will return FALSE.
<p>
  However, your program may use the
  <a href="api.htm#KeyGetSerialNumberStatus">KeyGetSerialNumberStatus</a>
  API to check if the call to
  <a href="api.htm#KeyCheck">KeyCheck</a> failed because of an invalid
  password, or if it failed because of an expired or locked out
  password.  If this is the case, beware that this function does not
  call any sophisticated code to get the status of the serial number; it
  simply returns the status set by the call to the embedded function
  that was called from inside the
  <a href="api.htm#KeyCheck">KeyCheck</a> routine.
<p>
  Since this is the case, a cracker can potentially change the SecureIt
  DLL to make
  <a href="api.htm#KeyGetSerialNumberStatus">KeyGetSerialNumberStatus</a>
  always return <em>snValid</em>, although
  it could obviously be caught by you if
  <a href="api.htm#KeyCheck">KeyCheck</a> returns FALSE and the status of
  the serial number is returned as valid.

<p>
<h3><a name="avoidpatch">How to avoid using a patched SecureIt DLL</h3>
<p>
  You can "fingerprint" the SecureIt DLL you are working with by
  calculating a checksum of it using the
  <a href="api.htm#KeyGetFileCheckSum">KeyGetFileCheckSum</a>
  API.  In your program, you could then (somewhere other than where your
  other SecureIt API functions are called) verify that this value is
  unchanged.  If it is different from what it was when you shipped the
  program, you know that something is fishy and should probably not
  bother calling any other SecureIt APIs.
<p>

<h3><a name="crash">How to crash a cracker's system</h3>
<p>
  As discussed in the <a href="api.htm">API chapter</a>, several
  programs using SecureIt can run concurrently - providing none of them
  have called the <a
  href="api.htm#KeyAllowDebugger">KeyAllowDebugger</a> API.

<p>
  This knowledge can be used to crash a potential cracker's system very
  easily - all you have to do is launch a program that calls SecureIt.
  This program can even be the program currently running, executed a
  second time with a special command line parameter signaling that this
  is a test execution.

<p>
  When your program sees this special command line parameter, it should
  call <a href="api.htm#KeySetup">KeySetup</a>, set a name and password
  using <a href="api.htm#KeySetNamePsw">KeySetNamePsw</a>, and call
  <a href="api.htm#KeyCheck">KeyCheck</a>.  Any name/password can be
  used; it does not even have to be a valid combination.  During one of
  the calls to the SecureIt APIs, the computer will hang or crash, if
  <a href="api.htm#KeyAllowDebugger">KeyAllowDebugger</a> was called in
  at least one of the processes; if not, you can allow the program to
  terminate.

<p>
  If you can make the program do something useful during this second
  execution, even better.  If you cannot, it still will be a major
  annoyance to a cracker, since it is not apparent that this second
  execution is part of the protection mechanism.

<h3><a name="whichunsafe">What other APIs are potentially unsafe?</h3>
<p>
  Theoretially, all of the APIs that return information could be patched
  to return data that your program thinks is "good".  The APIs in
  question are
<pre>
    <a href="api.htm#KeyGetRegisteredName">KeyGetRegisteredName</a>
    <a href="api.htm#KeyGetSerialNumber">KeyGetSerialNumber</a>
    <a href="api.htm#KeyGetSerialNumberStatus">KeyGetSerialNumberStatus</a>
    <a href="api.htm#KeyGetSerialNumberExpiry">KeyGetSerialNumberExpiry</a>
    <a href="api.htm#KeyGetFileChecksum">KeyGetFileChecksum</a>
    <a href="api.htm#KeyGetCRC32">KeyGetCRC32</a>
</pre>

<h2><a name="encoding">How the passwords are encoded</h2>
<p>
  A valid SecureIt password can be thought of as an array of integer
  numbers, which have been encrypted and subsequently encoded using a
  special data-to-character algorithm in the MakeKey program.
<p>
  The decoding mechanism of SecureIt, located in the
  <a href="api.htm#KeyCheck">KeyCheck</a> routine, first reverses the
  character encoding to convert the password string to form a list of
  numbers.
<p>
  If the option to RSA-encrypt the password data was enabled, the
  password is first decrypted using the public RSA key included in the
  data blob generated by the <a href="gendata.htm">GenData</a> program.  Then, a a 32-bit checksum
  of the list of numbers is calculated, and used as the seed for
  decrypting the number sequence itself.
<p>
  Once the numbers have been decoded in this manner, two fields are
  available in unencoded form: A seed value for further decoding and a
  bitmapped field containing information about how the data is
  structured in the rest of the password.

<p>
  The seed value extracted from the password in this manner is
  combined with a 32-bit checksum of the user name entered, and the
  remaining part of the password is decoded using this value. If the
  option to disregard high-ascii characters in the user name is enabled,
  this of course is obeyed.
<p>
  The number sequence is now partially decoded and needs to be validated
  and interpreted.  To do this, a routine embedded in the RSA-encrypted
  data blob generated by <a href="gendata.htm">GenData</a> is called.
  Since this routine is encoded using strong encryption, it is not
  possible to hack it or otherwise change the code, and the code
  performs two tasks: It checks if the serial number is valid and it
  performs the last stage of data decoding if it is.
<p>
  If the call to this code was succesful and the serial number was
  neither locked out or invalid, the version field is extracted and
  combined with the version set as the correct version by a call to
  <a href="api.htm#KeySetup">KeySetup</a> or
  <a href="api.htm#KeySetVersion">KeySetVersion</a>,
  and finally the list of user fields is
  decoded and stored in a structure that is used by later calls to
  <a href="api.htm#KeyQueryUserValue">KeyQueryUserValue</a>, etc.

<p>
  <a href="api.htm#KeyCheck">KeyCheck</a> returns TRUE if the serial
  number embedded is valid and the version stored in the decoded
  password and the one specified by <a href="api.htm#KeySetVersion">
  KeySetVersion</a> match.  No other checking is done, since the
  algorithm ensures that the rest of the data will be correct as well if
  these figures match.  A pirate can of course easily avoid this check,
  but by doing so does not gain access to or information about any of
  the other data encoded in the password - and if you use SecureIt
  correctly, the program will not run without it.
<p>
  Finally, if the check is ok and the Automatic parameter passed to
  <a href="api.htm#KeyCheck">KeyCheck</a> is TRUE, all Patch and CallBack
  fields are processed in order.
<p>

<h2><a name="debuggers">SecureIt and debuggers</h2>
<p>
  In order to make life more difficult for pirates, and to dissuade
  pirates from digging into the code to find out how it works and what it
  does, several tricks are being employed by SecureIt.
<p>
  Even though the methodology used by SecureIt is secure, there is no
  reason to allow snoops to take too close a look at the code - the
  earlier in the process the pirate can be dissuaded from spending more
  time on cracking your software protection, the better.
<p>
  Two of the techniques used are
<ul>
<li>
  If a program that uses SecureIt is run from within a debugger - even
  with a valid name/password combination - it will not work properly.
  Only when the program is run from outside a debugger will it
  correctly verify passwords.
<p>
  If you are very technical, you may want to know that this is done by
  raising both INT 3 instructions, which normally tells the debugger
  to stop executing if present, and INT 0 instructions, which normally
  signal a division by 0 fault.
<p>
<li>
  Several threads are used to perform different parts of the decoding
  sequence and semaphores are being used to coordinate the efforts of
  these threads.  A pirate not intimately familiar with OS/2 will
  immediately be in trouble - even prior to discovering that the
  executable contains few interesting plaintext strings, that critical
  bits of code are embedded in an RSA-encrypted blob of data and that
  it is not enough to simply bypass the <a href="api.htm#KeyCheck">KeyCheck</a> call.
</ul>
<p>
  See also the sections regarding SecureIt <a
  href="pitfalls.htm">pitfalls</a> and <a href="#crackit">How to crack
  SecureIt</a>.

<h2><a name="rsa">About RSA</h2>
<p>
  RSA is a secure cryptographic algorithm, invented by Rivest, Shamir
  and Adlemann - hence the name of it.

<p>
  RSA uses the concept of a key consisting of both a private and a
  public part, and is for example used to allow for secure e-mail
  communications in Zimmermann's excellent PGP (Pretty Good Privacy)
  product, which is available on the Net, for example at <a
  href="http://www.pgp.com">http://www.pgp.com</a>.

<p>
  Grossly simplified, the public part of an RSA key can be considered to
  be the product of two very large - maybe hundreds of digits long -
  prime numbers; the secret key consists of the two primes which
  multiplied to each other make up the public key.

<p>
  The public key is just that: Public.  Unless there has been a major
  breakthrough in the field of factoring a large number into its prime
  factors, the process of calculating the secret key based on the public
  one takes long enough for it to be considered impractical, if not
  impossible.  The public key can be distributed without any big risk of
  the secret key becoming known as well.

<p>
  The RSA algorithm ensures that data encrypted using the secret key can
  only be decrypted using the public key, and vice versa.  This makes it
  ideal for secure e-mail, where the public key is widely distributed to
  everyone with who, you wish to communicate securely.  If you want to
  send a mail to someone, you get their public key and encrypt the
  message using it: Only the holder of secret key will be able to read
  the message.  The other way is useful as well: By encrypting a small
  bit of text using your own secret key (which no-one else knows), you
  are able to uniquely sign your e-mails: Anyone with your public key
  can decrypt it and thus verify that you are indeed the sender of the
  message.

<h2><a name="secureitrsa">RSA in SecureIt</h2>
<p>
  In SecureIt, RSA encryption is used for multiple purposes: To ensure the
  integrity of sensitive string data, to make a system for verifying the
  expiration and locking of serial numbers, and to make it close to
  impossible to generate fake passwords for your application.

<p>
  The graphic in the <a href="overview.htm">overview</a> section of this
  document illustrates how the RSA key is generated and used by the
  various parts of SecureIt, and I will attempt to explain it in plain
  English below.

<ul>
  <li>
  Firstly, the RSA key is generated by the <a
  href="gendata.htm">GenData</a> program, with a bit length specified in
  the .GEN file used as input.  If GenData was run previously, it can
  read the RSA key from a data file containing both the secret and the
  public key instead of generating a new key on every run.

  <p>
  Having either generated or read the RSA key, GenData uses the secret
  key to encrypt the data specified in the .GEN file.  This data
  consists of user-defined strings, serial number restrictions and
  executable code defined by SecureIt; this code is always included in
  the data generated by GenData.

  <p>
  The public part of the RSA key is then appended to the generated
  (RSA-encrypted) data blob and stored in a format appropriate for
  inclusion in your program.
  <p>

  <li>
  Next, <a href="makekey.htm">MakeKey</a> is executed in order to
  generate a valid password for the application.  MakeKey reads the data
  file containing both the public and the secret RSA keys generated by
  GenData; if this file does not exist, MakeKey refuses to generate an
  RSA-encrypted password.

  <p>
  MakeKey then generates the data to be stored in the password string,
  based on the .KEY setup file.  The data is encrypted using the secret
  RSA key and is converted to a human-readable text string which you can
  give to your user.
  <p>

  <li>
  In the application itself, the <a href="api.htm#KeySetup">KeySetup</a>
  API is called with the data generated by GenData previously as the
  parameter.  KeySetup extracts the public RSA key from the data blob
  and uses it to decrypt the rest of the encrypted data - which was
  encrypted using the secret key during the GenData process.

  <p>
  When the <a href="api.htm#KeyCheck">KeyCheck</a> API is called to
  verify a name and password, the public key previously extracted in the
  KeySetup call is used again.  First, the password string is converted
  from text to data, and is then decrypted using the public RSA key.

  <p>
  Once decrypted, the data is checked for validity by checking the
  serial number embedded in the password against the list of locked and
  date-restricted ones specified by the GenData data, using the
  executable code also included by GenData.

  <p>
  If this process is succesful, the version number embedded in the
  password string is compared to the one defined as being the valid one
  in the call to KeySetup, and KeyCheck returns either True or False
  based on the result.
  <p>

  <li>
  At various points throughout the program, you will want to retrieve
  the string data also stored in the RSA encrypted data block generated
  by GenData.  When you call the <a
  href="api.htm#KeyGetUserString">KeyGetUserString</a> API to do this,
  SecureIt calls the <b>same entrypoint</b> that was used when
  validating the serial number in the password for retrieving the
  string.  Thus, if someone simply attempts to remove the function call
  from the SecureIt DLL, your program will not be able to display any of
  the text strings embedded in the data blob either...
</ul>

<h2><a name="crackit">How to crack SecureIt - discussion</h2>
<p>
  "Yeah, sure", you think, " - but what would it really take if someone
  wanted to crack my program or generate fake passwords for it.  What
  kind of effort would be involved if someone really, really wanted to
  do it?"

<p>
  Assuming you have enabled the options to provide good security, ie
  used a reasonable RSA key length in GenData, RSA encrypt the password,
  include a serial number, and have embedded a goodly number of strings
  in the data blob, it would be quite difficult to do.  Let's take a
  look at what would be involved...

<p>
  Initially, the cracker would have to get around the anti-debugger code
  employed by SecureIt.  If not, the cracker will see his machine
  hang/crash every time he tries to trace into any of the interesting
  functions.  This is actually not particularly difficult to do,
  since it simply involves finding and calling the
  <a href="api.htm#KeyAllowDebugger">KeyAllowDebugger</a> API in the
  SecureIt DLL; the main problem is to find "room" for calling this API
  and inserting the code to do so in a precompiled program.  Let us
  assume the cracker is clever and experienced enough to do this, and
  moves on.

<p>(As an aside, I could have included a different version of the
  SecureIt DLL without the KeyAllowDebugger API, which could be used for
  distribution.  However, as will be seen a bit further down, the
  cracker will need a valid registration of both SecureIt and your
  program in order to use this for anything, so I decided not to do
  this.  The anti-debugger code does not provide any real security
  anyway, and is primarily included to ward off the casual cracker).

<p>
  For instructions on how to foil attempts to call
  <a href="api.htm#KeyAllowDebugger">KeyAllowDebugger</a>, please refer
  to the section above regarding <a href="#crash">How to crash a
  cracker's system</a>.

<p>
  The first SecureIt API to be called is <a
  href="api.htm#KeySetup">KeySetup</a>; in order to be able to generate
  fake passwords, the cracker would have to trace into this call,
  extract the public RSA key embedded in the data blob, and figure out
  what the corresponding secret RSA key used to encrypt the passwords
  might be.  As discussed in the <a href="rsa">About RSA</a> section
  above, this is probably unlikely to happen due to the mathemathics
  involved.  If you believe what you read on the Internet, there are
  figures floating around estimating the time it would take to crack an
  RSA key is on the order of thousands or maybe millions of years using
  current technology.  Even allowing for further rapid advances in
  processing power, this should be enough for most purposes.

<p>
  Without the secret RSA key, the cracker is unable to generate valid
  passwords for the unchanged original executable and the only option left
  if he really wants to be able to generate passwords is to change the
  public key used to decrypt them, so he can define his own
  secret/public key pair to use for generating them.  To do this, he
  would have to have a full copy of SecureIt and go through the decrypted
  data to generate a GenData setup file identical to the one you used -
  probably removing the serial number restrictions.  He would then have
  to patch the executable file to include <b>his</b> data blob encrypted
  using his own secret RSA key, and this may indeed be possible to do.

<p>
  There are a few problems with this approach though.  The most obvious
  one is that he has to make a very large change to the executable
  (substituting a few kB of the original one), and that the legitimate
  passwords issued by yourself will not work with his patched version,
  since the RSA key used to decrypt the data blob and hence the
  passwords is not the one you originally included in the file.  A less
  serious obstacle the cracker is faced with is that you may have used
  OS/2's ExePack to compress the executable when you linked it; in order
  to modify it, he needs to decompress it, change the code, and
  maybe re-compress the executable before it becomes useable again.

<p>
  Changing the executable also affects its checksum.  If your code
  includes a verification of the checksum of the executable itself, or
  parts thereof (Using either the
  <a href="api.htm#KeyGetFileChecksum">KeyGetFileChecksum</a> or
  <a href="api.htm#KeyGetCRC32">KeyGetCRC32</a> APIs), the cracker will
  obviously have to find and remove these calls as well.

<p>
  Even having done all of this, the cracker is still not ready to issue
  fresh passwords for his "customized" version of the program.  In order
  to be able to generate passwords, he must have a valid password
  already - in other words, he must have purchased a licence for it.
  He needs the valid password in order to be able to generate a .KEY
  file for MakeKey, containing all the correct settings for CallBack,
  UserValue and CodePatch fields your program uses, or his crack is
  useless.

<p>
  The limitations of the very tedious crack outlined above may lead the
  cracker to try a different approach: Making a generic crack to the
  SecureIt DLL file, so all programs using SecureIt would be registered
  by default if only they used this changed DLL instead of the original
  one.

<p>
  If you have studied this document, it should be obvious that this
  approach is not feasible.  Since each program using SecureIt will have
  different data encoded in the password strings, use different RSA keys
  for decrypting the data blob passed to KeySetup, and have different
  strings stored in the data blob itself, making a generic patch that
  just lets KeyCheck return TRUE in every instance is possible, but will
  not gain the cracker much.  Only programs protected with minimal
  use of SecureIt features (No user strings and no data in the password,
  as in the Prot1 example) will be affected by this.  Again, it cannot be
  stressed enough: For good security, <b>use</b> the features of
  SecureIt!

<p>
  The last approach to cracking a program (that I can think of) using
  SecureIt is more direct, and simply involves changing the code to call
  whatever CallBack functions you have, manually perform any CodePatch
  fields defined in the password, and hard code User Values into the
  executable.

<p>
  This also will be very difficult, partly because the SecureIt
  functions are located in a DLL instead of being statically linked into
  the executable.  Let's look at what is involved in removing the need
  for each of the three field types normally embedded in the password.

<p>
  In the case of UserValue fields, the cracker needs to localise every
  piece of code that retrieves one, and change it to load the correct
  constant instead.

<p>
  For CodePatch fields, the executable needs to be changed to reflect
  the changes done by each field, although this will obviously not work
  if you call the code both before and after it is patched, and expect
  different results.  For example, you may have patched a calculation
  routine to return a wrong result (say, changed an ADD instruction to
  SUB) and first call the unpatched function, then perform the patch (by
  calling <a href="api.htm#KeyCodePatch">KeyCodePatch</a> and finally
  call the function again - and use both results for something.

<p>
  Callback fields are also quite tricky to get around.  To patch the
  executable to call the desired functions, he not only needs to patch
  the code where the call takes place, but also needs to (know about
  and) modify the relocation table stored in the header of the
  executable.

<p>
  This problem of relocations is cumbersome to get around, and requires
  both patience and an intimate knowledge of the program loader to do.
  For example, consider the following simple code extract which calls
  KeyQueryUserValue to retrieve a user value from the password (if you
  are unfamiliar with assembler, you can stop reading now :)

<pre>
  //  x := KeyQueryUserValue(0);
  cs:1017E 6A00            push   0
  cs:10180 E863108E0C      call   C8F11E8h
  cs:10185 83C404          add    esp,4
  cs:10188 A3E40E0200      mov    [20EE4h],eax
</pre>

  To change this code from relying on the password data and SecureIt,
  the cracker would probably locate the code in the .EXE file and patch
  it to read something like (assuming the correct user value is 0x12345678,
  hex):

<pre>
  //  Hacked version; x := 0x12345678
  cs:1017E B878563412      mov    eax,12345678h
  cs:10183 90              nop
  cs:10184 90              nop
  cs:10185 90              nop
  cs:10186 90              nop
  cs:10187 90              nop
  cs:10188 A3E40E0200      mov    [20EE4h],eax
</pre>

  This does not work, however!  There used to be a CALL instruction in
  the middle of the code, and the program loader applies a relocation to
  the call address after the code has been copied to the correct
  location and before execution resumes.  The cracker is faced with code
  that looks like this, instead of what was intended:

<pre>
  cs:1017E B878566310      mov    eax,10635678h
  cs:10183 8E0C90          mov    cs,Word Ptr [eax+edx*4]
  cs:10186 90              nop
  cs:10187 90              nop
  cs:10188 A3E40E0200      mov    [20EE4h],eax
</pre>

  Not only does this code not load the desired value into the eax
  register, it also causes the program to crash, because it is quite
  unlikely that the address pointed to in the unexpected mov cs
  instruction is one that contains a valid value for the CS selector.

<p>
  The relocations are required because the SecureIt DLL is loaded to
  a different address every time your program is started.  The
  executable code inside your program thus contains information that a
  call will be made, but not the absolute address - when the DLL is
  loaded, OS/2 adjusts the actual CALL statement to point to the address
  at which the required API has been loaded.  Obviously, if the code has
  been patched to no longer be a CALL, the result is likely to be as
  shown above.

<p>
  If the SecureIt code had been statically linked into the executable
  however, no relocation would be required since the base load address
  is known at link-time: 0x1000 hex.  This is the reason for the
  statement above, that "SecureIt in a DLL provides better protection
  than a statically linked version of it".

<p>
  I do not think it is unreasonable to say that only the most determined
  hacker would ever have gotten this far, and the program is still far
  from being cracked - we just failed making a patch for something as
  simple as a UserValue field, not to mention the CodePatch and CallBack
  fields.  Or your checking of the CRC or the executable itself.  Or
  even the requirement that the cracker must already have a valid
  password to even get started...

<p>
  As the discussion above shows, it is probably possible to crack a
  program using SecureIt for protection, provided enough effort it is
  put into it.  However, it is <b>not</b> possible to make a password
  generator that will generate valid passwords for your application, and
  it is <b>not</b> possible to make a generic patch that will work on
  all SecureIt-protected applications.

<h2><a name="whynot100">Why is SecureIt not 100% safe?</h2>
<p>
  If you have read the above, you may wonder why SecureIt is not made in
  a way that is 100% safe against crackers.  The answer is: It is not
  possible, unfortunately.

<p>
  If we were in a situation where we wanted to make sure no-one could
  access the program, it could be done - but this is not the purpose,
  since this would prevent anyone from executing it as well.

<p>
  After all, SecureIt protects an executable program, one which you want
  your legitimate users to be able to use with no problems.  This means,
  that you want all parts of the program to be available at some point,
  including ones that are protected.  At some point, irrespective of
  clever encryption and protection schemes, the entire program is
  available in its correct executable form.

<p>
  Given that this is the case, we have to accept the second best
  solution, which is what SecureIt implements.

</body>
</html>
