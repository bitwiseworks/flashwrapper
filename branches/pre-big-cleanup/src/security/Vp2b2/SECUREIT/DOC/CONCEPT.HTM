<HTML>
<HEAD>
  <TITLE>SecureIt - The concept</TITLE>
</HEAD>
<body background="backgrnd.gif" onLoad="parent.index.location.href='concept.inx'; return true">
<h1>The Crippleware concept</h1>

<p>
  The key to providing pirate-proof shareware is to cripple it, ie to
  not provide full functionality in the generally available demo version
  of the software.  If the entire functionality is available, and all it
  takes for the software to be "registered" is the state of a boolean
  variable or function to unlock it, someone will and can do just that.

<p>
  By all means, make the registered-only functions the obscure or rarely
  used ones, since you want prospective buyers to be able to determine
  the quality of your software without being unduly hindered by
  restricted functionality.  However, if you want good protection
  against pirates, you must leave some core piece of functionality out.

<p>
  SecureIt itself is distributed as crippleware.  Without a registration
  key, you can include the code in your programs, make all the checks,
  etc - but you cannot generate valid keys for your users to unlock your
  own programs.

<p>
  SecureIt is of course protected with itself, and requires a valid
  combination of username and password to be unlocked.  When executed,
  the <a href="makekey.htm">MakeKey</a> programs checks whether the file
  SecureIt.Ini is available and reads the name/password combination from
  there. If the file does not exist, it prompts you for a name and
  password and saves these in SecureIt.Ini for future use if they are
  correct.

<p>
  By now, countless sceptics have tried in vain to break SecureIt; to
  my knowledge, none have succeeded.

<h2><a name="how">What to cripple</h2>
<p>
  Deciding how to limit the functionality of a publicly available demo
  version is a hard choice, where several conflicting factors need to be
  weighed against each other.

<p>
  Firstly, the user must be able to properly evaluate the software.  If
  the functionality is so limited that it becomes close to useless, a
  prospective buyer is less likely to buy it - not the desired outcome.

<p>
  Secondly, the user should be given a strong incentive to buy the
  software.  History has shown that shareware distributed as fully
  functional does not registered as often as programs that are crippled
  or otherwise different from the full version.  In a perfect world, the
  quality of a good program should be enough of an incentive - alas, the
  world is not quite perfect yet.

<p>
  Lastly, you want to protect your work from being abused.  Most authors
  feel that users that do not register should not continue to use the
  software, but are largely powerless to do anything about it if the
  user disregards carefully worded 30-day evaluation licences.

<p>
  You have several options, and the final decision about how you protect
  your program is yours to make.

<p>
  The simplest method, which does not require intimate knowledge about
  code generation is to make good use of User Values.  A User Value is a
  4-byte integer stored in the password, and by embedding vital
  hard-to-guess information here, you have come a long towards
  implementing good security.  User Values can be used in an almost
  infinite number of ways - here are some ideas:

<ul>
  <li>Store values you would otherwise embed as constants in your
  program in user values.  This could be FOR loop boundaries or other
  constant data, <p>

  <li>Store more than one value in each user field; after all, there is
  room for 4 byte-sized constants or two 16-bit constants in a single
  user value, <p>

  <li>Store the checksum of your executable in a user value and check
  this value against the real checksum.  Since the passwords cannot be
  faked, this provides some proof against tampering, <p>

  <li>Store the seed of a pseudo-random routine you use to decrypt a
  larger amount of data with in a user field.  Without this information,
  the cracker will have to try all possible 2 billion values.
</ul>

<p>
  If you know how, use a call back and a code patch field in addition to
  a few user value fields.  A call back field stores the absolute or
  relative address of an entrypoint in the password; your code should
  require this code to be called before registered features are enabled,
  and should not call this code from anywhere else.

<p>
  If you know something about assembler programming and code generation,
  a CodePatch field provides some security as well.  The best used code
  patch fields are used to patch small amounts of code from something
  that <em>looks</em> right (but is not!) to code that really does the
  right thing.  This will typically involve a computation of some sort,
  like performing a subtraction where an addition is really required, or
  something similar.

<p>
  I hope the above is enough for you to get an idea of the possibilites
  that are open to you when using SecureIt.  If not, please refer to the
  rest of this documentation - and do not hesitate in writing me an
  e-mail asking for advice about protecting your program.  For details
  about how to do this, please refer to the
  <a href="contact.htm">contact addresses</a> section.
</body>
